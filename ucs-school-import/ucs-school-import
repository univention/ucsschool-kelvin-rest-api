#!/usr/bin/python2.4 -OO
# -*- coding: utf-8 -*-
#
# Univention UCS@School
#
# Copyright (C) 2007-2010 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# Binary versions of this file provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

#-> doesn't do:
# check usernames for correct values (no spaces)
# change the user's position in the tree (change the school i.e.)
# select Schools that are separated by kommata
# modify users school or type (pupil/teacher)

#-> needs definition:
# import access rights

# init list of created users and passwords
created_users = {}
# string of problems during process
problem_hints = ""
# separator char in infile (default: \t for Tabulator)
sepchar='\t'

# wipe the following trailing and leading characters from group names
wipe_char_group='-'

# count access to ldap to reconnect after 1000 changes
locounts=0

import sys, string, re, codecs, os, copy, random, time, traceback, re
import subprocess
import tempfile
import ipaddr

import univention.debug
univention.debug.init('/var/log/univention/admin-cmd.log', 1, 0)

import univention.admin.uldap
import univention.admin.modules
import univention.admin.objects
import univention.config_registry

configRegistry=univention.config_registry.ConfigRegistry()
configRegistry.load()

baseDN=configRegistry['ldap/base']
domainname=configRegistry['domainname']

# FIXME: Are e-mail addresses provided?? otherwise it might be useful to
# configure this via UCR
#externaldomainname='schule.berlin.de'

district_enabled = False
if configRegistry['ucsschool/ldap/district/enable'].lower () in ('1', 'yes', 'true'):
	district_enabled = True

school_dcs = configRegistry['ucsschool/ldap/default/dcs']
# create edukativ DC by default
if school_dcs.strip () == '':
	school_dcs = 'edukativ'

verified_ous          = []
verified_groups       = []
verified_group_shares = []

cn_pupils   = configRegistry.get('ucsschool/ldap/default/container/pupils', 'schueler')
cn_teachers = configRegistry.get('ucsschool/ldap/default/container/teachers', 'lehrer')
cn_admins	= configRegistry.get('ucsschool/ldap/default/container/admins', 'admins')
cn_staff	= configRegistry.get('ucsschool/ldap/default/container/staff', 'mitarbeiter')

grp_prefix_pupils   = configRegistry.get('ucsschool/ldap/default/groupprefix/pupils', 'schueler-')
grp_prefix_teachers = configRegistry.get('ucsschool/ldap/default/groupprefix/teachers', 'lehrer-')
grp_prefix_admins	= configRegistry.get('ucsschool/ldap/default/groupprefix/admins', 'admins-')
grp_prefix_staff	= configRegistry.get('ucsschool/ldap/default/groupprefix/staff', 'mitarbeiter-')

grp_policy_pupils	= configRegistry.get('ucsschool/ldap/default/policy/umc/pupils', 'cn=ucsschool-umc-pupils-default,cn=console,cn=policies,%s' % baseDN)
grp_policy_teachers = configRegistry.get('ucsschool/ldap/default/policy/umc/teachers', 'cn=ucsschool-umc-teachers-default,cn=console,cn=policies,%s' % baseDN)
grp_policy_admins	= configRegistry.get('ucsschool/ldap/default/policy/umc/admins', 'cn=ucsschool-umc-admins-default,cn=console,cn=policies,%s' % baseDN)
grp_policy_staff	= configRegistry.get('ucsschool/ldap/default/policy/umc/staff', 'cn=ucsschool-umc-staff-default,cn=console,cn=policies,%s' % baseDN)

role_pupil   = 'pupil'
role_teacher = 'teacher'
role_staff   = 'staff'

generate_logins = configRegistry.get('ucsschool/import/generate/logins', 'no').lower() in ( 'yes', 'true', '1' )

# IP address prefix len conecerning the netmask
default_prefixlen = 24

if not (cn_pupils and cn_teachers and cn_admins and cn_staff):
	print 'ERROR: Unable to proceed: one of these UCR variables is not set correctly:\n\tucsschool/ldap/default/container/pupils\n\tucsschool/ldap/default/container/teachers\n\tucsschool/ldap/default/container/staff\n\tucsschool/ldap/default/container/admins'
	sys.exit (1)

# exception classes
class DeleteObjectError( Exception ): pass
class CreateObjectError( Exception ): pass

class Hooks( object ):
	OBJECTS = ( 'user', 'group', 'printer', 'computer', 'network', 'router', 'ou' )
	OPERATIONS = { 'A' : 'create', 'M' : 'modify', 'D' : 'remove' }

	PATH = '/usr/share/ucs-school-import/hooks/'

	def _create_temp_file( self, line ):
		tmpfile = tempfile.NamedTemporaryFile()
		tmpfile.write( line )
		tmpfile.flush()
		return tmpfile

	def __run( self, phase, module, action, **kwargs ):
		# verify phase
		if not action in Hooks.OPERATIONS:
			return False

		# verify path
		path = os.path.join( Hooks.PATH, '%s_%s_%s.d' % ( module, Hooks.OPERATIONS[ action ], phase ) )
		if not os.path.isdir( path ) or not os.listdir( path ):
			return False

		# create temporary file with data
		if 'line' in kwargs:
			tmpfile = self._create_temp_file( kwargs.get( 'line' ) )

		# invoke hook scripts
		# <script> <temporary file> [<ldap dn>]
		command =  [ 'run-parts', path ]
		if 'line' in kwargs:
			command.extend( ( '--arg', tmpfile.name ) )
		if 'dn' in kwargs:
			command.extend( ( '--arg', kwargs[ 'dn' ] ) )

		ret_code = subprocess.call( command )

		# close temporary file (also deletes the file)
		if 'line' in kwargs:
			tmpfile.close()

		return ret_code == 0

	def pre( self, module, action, **kwargs ):
		return self.__run( 'pre', module, action, **kwargs )

	def post( self, module, action, **kwargs ):
		return self.__run( 'post', module, action, **kwargs )

hooks = Hooks()

class ucsschool_person_modify:
	def __init__(self,line):

		# parse line here
		parsed = line.strip('\r\n').split(sepchar)

		self.modtype   = parsed[0] # A,M or D: add, modify or delete
		self.login     = parsed[1].lower ()
		self.sname     = parsed[2] # surename
		self.name      = parsed[3] # first name
		self.sNr       = parsed[4] # schoolNr(s)
		self.cNr       = parsed[5] # classNr
		self.rights    = parsed[6] # users which may change this entry
		self.mail      = parsed[7]

		def parseBoolstring (parsed, idx, default='0'):
			res = default
			if len (parsed) > idx:
				string = parsed[idx]
				if string and string[0] == '1':
					res = '1'
			return res

		self.isTeacher = parseBoolstring (parsed, 8)
		self.isActive  = parseBoolstring (parsed, 9, default='1')
		self.isStaff   = parseBoolstring (parsed, 10)
		self.problem_hints = ""

		if generate_logins:
			if self.isTeacher == "1" or self.isStaff == "1":
				self.login = ('%s.%s' % (self.name[0], self.sname[:8])).lower()
				print "DEBUG: Teacher found: creating login name " + self.login
			else:
				self.login = self.name[:6].lower()
				print "DEBUG: Student found: creating login name " + self.login

		if ',' in self.sNr:
			self.allsNrs= self.sNr.split(',')
			self.sNr=self.allsNrs[0]
			self.other_sNr=self.allsNrs[1:]
		else:
			self.allsNrs=[self.sNr]
			self.other_sNr=[]

		# split into multiple class number if comma is present
		if ',' in self.cNr:
			self.cNr = self.cNr.split(',')
		else:
			self.cNr = [ self.cNr ]
		# wipe invalid character from class numbers
		for i in range(len(self.cNr)):
			self.cNr[i] = self.wipeInvalidCharGroup( self.cNr[i] )
		# remove empty strings
		self.cNr = [ x for x in self.cNr if x ]
		# sort classes
		self.cNr.sort()

	def wipeInvalidCharGroup(self, groupName):
		global wipe_char_group

		ok = False
		while groupName and not ok:
			if groupName[0] in wipe_char_group:
				groupName = groupName[1:]
			else:
				ok = True
		ok = False
		while groupName and not ok:
			if groupName[-1] in wipe_char_group:
				groupName = groupName[0:-1]
			else:
				ok = True
		return groupName

	def getOtherPersons(self):
		persons=[]

		for schoolNr in self.other_sNr:
			person = copy.deepcopy(self)
			person.login = ("%s_%s"%(self.login,schoolNr)).lower ()
			person.sNr=schoolNr
			person.other_sNr=[] # has no "slave"-accounts
			self.mail="" # no extra mail address
			person.cNr=[] # no class in other ou
			person.isTeacher = '0'
			person.isStaff = '0'
			if role_teacher in self.getRole ():
				person.isTeacher = '1'
			if role_staff in self.getRole ():
				person.isStaff = '1'

			persons.append(person)

		return persons

	def getPosition_dn(self):
		# resolution order for the position is pupil, teacher, staff
		cn = cn_pupils
		if role_teacher in self.getRole ():
			cn = cn_teachers
		elif role_staff in self.getRole ():
			cn = cn_staff
		return "cn=%s,cn=users,%s" % (cn, getDN (self.sNr))

	def getDN(self):
		return "uid="+self.login+","+self.getPosition_dn()

	def default_groups(self):
		default_groups=[]

		# default group
		default_groups.append("cn=Domain Users "+self.sNr+",cn=groups,%s" % (getDN (self.sNr), ))

		for role in self.getRole ():
			user_grp_prefix = { role_teacher:grp_prefix_teachers,
							    role_pupil:grp_prefix_pupils,
							    role_staff:grp_prefix_staff }[role]
			# class if available
			for cnr in self.cNr:
				default_groups.append("cn=" + cnr + ",cn=klassen,cn=%s,cn=groups,%s" % (cn_pupils, getDN (self.sNr)))

			default_groups.append("cn=%s%s,cn=groups,%s"%(user_grp_prefix, self.sNr, getDN (self.sNr)))

		return default_groups

	def getRole(self):
		"""returns the user's roles"""
		roles = []
		if self.isTeacher == '1':
			roles.append (role_teacher)
		if self.isStaff == '1':
			roles.append (role_staff)
		if not roles:
			roles.append (role_pupil)
		return roles

def count_lo():
	pass # was a workaround for slapd locking-failures, not necessary any more
	global locounts
	global lo
	locounts=locounts+1
	#print 'locounts %s'%locounts,
	if locounts>1000:
		try:
			print 'ldap-lookup count exceeded, reconnect'
			lo=univention.admin.uldap.access(host=configRegistry['ldap/master'], base=baseDN, binddn='cn=admin,'+baseDN, bindpw=pwd, start_tls=tls)
			locounts=0
		except Exception, e:
			univention.debug.debug(univention.debug.ADMIN, univention.debug.WARN, 'authentication error: %s' % str(e))
			print 'ERROR: authentication error: %s' % str(e)
			sys.exit(1)

def extract_district (schoolNr):
	try:
		return schoolNr[:2]
	except IndexError:
		# TODO: add more debug output
		print "ERROR: Unable to extract district from school number: %s' % schoolNr + \
				'\n\tIf you don't use the district model deactivate UCR variable ucsschool/ldap/district/enable"

def getDN (schoolNr, base='school', basedn=baseDN):
	"""
	@param	base Values are either school, district or base
	@return	According to the base a specific part of dn is returned.
			Let's suppose the following school dn:
			ou=SCHOOL,ou=DISTRICT,dc=BASE,dc=DN

			The following is returned
			'base'		-> dc=BASE,dc=DN
			'district'	-> ou=DISTRICT,dc=BASE,dc=DN
			'school'	-> ou=SCHOOL,ou=DISTRICT,dc=BASE,dc=DN
	"""
	dn = '%(school)s%(district)s%(basedn)s'
	values = {'school':'ou=%s,'%schoolNr, 'district':'', 'basedn':basedn}
	if district_enabled:
		district = extract_district (schoolNr)
		if not district:
			print "ERROR: Unable to continue execution without district number. School number: %s" % schoolNr
			sys.exit(1)
		values['district'] = 'ou=%s,' % district
	if base == 'district':
		values['school'] = ''
	elif base == 'base':
		values['district'] = ''
		values['school'] = ''
	return dn % values


def verify_policy(objdn, schoolNr, policy_dn_list):
	# test if all policy objects exist and if all referenced objects are policy objects
	global problem_hints
	for poldn in policy_dn_list:
		oc = lo.get( poldn, ['objectClass'] )
		if not oc:
			print "Object to be referenced does not exist: " + poldn
			problem_hints = problem_hints + "there were problems verifying ou %s: Object to be referenced does not exist: %s\n" % (schoolNr, poldn)
			break
		elif not 'univentionPolicy' in oc['objectClass']:
			print "Object to be referenced is no valid policy: " + poldn
			problem_hints = problem_hints + "there were problems verifying ou %s: Object to be referenced is no valid policy: %s\n" % (schoolNr, poldn)
			break
	else:
		# add univentionPolicyReference if neccessary
		oc = lo.get( objdn, ['objectClass'] )
		if not 'univentionPolicyReference' in oc.get('objectClass',[]):
			try:
				lo.modify( objdn, [ ('objectClass','','univentionPolicyReference') ] )
			except:
				print 'Objectclass univentionPolicyReference cannot be added to %s\n' % (objdn)
				problem_hints = problem_hints + "there were problems verifying ou %s: Objectclass univentionPolicyReference cannot be added to %s\n" % (schoolNr, objdn)
		# add all missing policies
		pl = lo.get( objdn, ['univentionPolicyReference'] )
		modlist=[]
		for poldn in policy_dn_list:
			if not poldn in pl.get('univentionPolicyReference',[]):
				modlist.append(('univentionPolicyReference','',poldn))
				print 'need to attach policy: %s' % poldn
		try:
			lo.modify(objdn, modlist)
		except:
			print 'Policies %s cannot be referenced to %s\n' % (policy_dn_list, objdn)
			problem_hints = problem_hints + "there were problems verifying ou %s: policies %s cannot be referenced to %s\n" % (schoolNr, policy_dn_list, objdn)


def verify_school_ou(schoolNr, co, lo, baseDN, dcName=None):
	global problem_hints

	if schoolNr in verified_ous:
		print "verify ou for school nr %s already done"%schoolNr
		return True

	# create ucsschool container if it does not exists
	created, dn = verify_container ('cn=ucsschool,cn=groups,%s' % baseDN, cn_module, co, lo, superordinate, baseDN, 'groupPath')

	if district_enabled:
		verify_container(getDN (schoolNr, base='district'), ou_module, co, lo, superordinate, baseDN)

	print "verify ou for school nr %s"%schoolNr
	# list of needed sub-containers, the dictionary-key adds the container as default during create in verify_container
	container={'0printerPath':['cn=printers'],
			   '1userPath':['cn=users','cn=%s,cn=users' % cn_pupils,'cn=%s,cn=users' % cn_teachers,'cn=%s,cn=users' % cn_staff,'cn=%s,cn=users' % cn_admins],
			   '2computerPath':['cn=computers','cn=server,cn=computers'],
			   '3networkPath':['cn=networks'],
			   '4groupPath':['cn=groups','cn=%s,cn=groups' % cn_pupils,'cn=%s,cn=groups' % cn_teachers,'cn=%s,cn=groups' % cn_staff,'cn=klassen,cn=%s,cn=groups' % cn_pupils,'cn=raeume,cn=groups'],
			   '5dhcpPath':['cn=dhcp'],
			   '6policyPath':['cn=policies'],
			   '7sharePath':['cn=shares','cn=klassen,cn=shares'],
			   '8none':['cn=dc,cn=server,cn=computers']
			   }
	# FIXME: die Policies sollten besser mit der Gruppe verknüpft werden, um
	# z.B. Mitarbeiter und Lehrer im selben Container pflegen zu können
	#container_policies = { 'cn=%s,cn=users' % cn_teachers: ['cn=default-lehrer,cn=console,cn=policies,' + baseDN] }
	container_policies = { }

	ou_base = getDN (schoolNr)

	# invoke pre hooks
	if dcName:
		dccn = dcName
	else:
		dccn = ''
	myline = '%s\t%s' % ( schoolNr, dccn )
	hooks.pre( 'ou', 'A', line = myline )

	created, dn = verify_container(ou_base, ou_module, co, lo, superordinate, baseDN, path='')
	keys=container.keys()
	keys.sort()
	for path in keys:
		for dn in container[path]:
			if path[1:]=='none': path=' '
			verify_container('%s,%s'%(dn,ou_base),cn_module, co, lo, superordinate, baseDN, path=path[1:])

	# create groups if not exsistant
	groups=[ ( "cn=%s%s,cn=ouadmins,cn=groups,%s" % (grp_prefix_admins, schoolNr.lower(), baseDN), grp_policy_admins ),
			 ( "cn=%s%s,cn=groups,%s" % (grp_prefix_pupils, schoolNr.lower(), getDN(schoolNr)),	grp_policy_pupils ),
			 ( "cn=%s%s,cn=groups,%s" % (grp_prefix_teachers, schoolNr.lower(), getDN(schoolNr)),	grp_policy_teachers ),
			 ( "cn=%s%s,cn=groups,%s" % (grp_prefix_staff, schoolNr.lower(), getDN(schoolNr)),	grp_policy_staff ),
			 ]
	for group, grppolicy in groups:
		verify_group(group, co, lo, superordinate, baseDN)
		if grppolicy and grppolicy.lower() != 'none':
			verify_policy(group, schoolNr, [ grppolicy ])

	groups=[
			"cn=DC-Verwaltungsnetz,cn=ucsschool,cn=groups,%s" % (baseDN, ),
			"cn=Member-Verwaltungsnetz,cn=ucsschool,cn=groups,%s" % (baseDN, ),
			"cn=DC-Edukativnetz,cn=ucsschool,cn=groups,%s" % (baseDN, ),
			"cn=Member-Edukativnetz,cn=ucsschool,cn=groups,%s" % (baseDN, ),

			"cn=OU%s-DC-Verwaltungsnetz,cn=ucsschool,cn=groups,%s" % (schoolNr.lower (), baseDN),
			"cn=OU%s-Member-Verwaltungsnetz,cn=ucsschool,cn=groups,%s" % (schoolNr.lower (), baseDN),
			"cn=OU%s-DC-Edukativnetz,cn=ucsschool,cn=groups,%s" % (schoolNr.lower (), baseDN),
			"cn=OU%s-Member-Edukativnetz,cn=ucsschool,cn=groups,%s" % (schoolNr.lower (), baseDN),
			]
	for group in groups:
		verify_group(group, co, lo, superordinate, baseDN)


	for dc in school_dcs.split ():
		if dcName:
			dccn = dcName
		else:
			dccn = 'dc%s-01' % schoolNr.lower ()
		dcgroups = ["cn=OU%s-DC-Edukativnetz,cn=ucsschool,cn=groups,%s" % (schoolNr.lower (), baseDN),
					"cn=DC-Edukativnetz,cn=ucsschool,cn=groups,%s" % (baseDN, )]

		if dc == 'verwaltung':
			if dcName:
				dccn = '%sv' % dcName
			else:
				dccn = 'dc%sv-01' % schoolNr.lower () # this is the name convention, a trailing v for Verwaltungsnetz DCs
			dcgroups = ["cn=OU%s-DC-Verwaltungsnetz,cn=ucsschool,cn=groups,%s" % (schoolNr.lower (), baseDN),
					"cn=DC-Verwaltungsnetz,cn=ucsschool,cn=groups,%s" % (baseDN, )]

		# create server if not exsistant
		objects = univention.admin.modules.lookup(computer_module, co, lo, scope='sub', superordinate=superordinate, base=baseDN,
												  filter=univention.admin.filter.expression('cn', dccn))
		count_lo()

		# * check if computer exists
		# * if computer is exists, test the following things
		#   * is computer a dc master or dc backup ==> do not add computer to any groups
		#   * is computer a dc slave ==> add computer to groups specified by dcgroups
		#   * is computer no dc ==> return error and exit
		# 

		# create server if not existent
		server_exists=0
		is_master_or_backup = False
		is_slave = False
		correct_server_exists=0
		if objects:
			server_exists = 1 # can't create another server with this id
			correct_server = "cn=%s,cn=dc,cn=server,cn=computers,%s"%(dccn, getDN (schoolNr))
			for object in objects:
				if object.dn == correct_server:
					correct_server_exists=1

		if server_exists:
			# check if existing system is a DC master or DC backup
			masterobjs = univention.admin.modules.lookup(dcmaster_module, co, lo, scope='sub', superordinate=superordinate, base=baseDN,
														 filter=univention.admin.filter.expression('cn', dccn))
			backupobjs = univention.admin.modules.lookup(dcbackup_module, co, lo, scope='sub', superordinate=superordinate, base=baseDN,
														 filter=univention.admin.filter.expression('cn', dccn))
			is_master_or_backup = ( masterobjs or backupobjs )
			# check if existing system is a DC slave
			slaveobjs = univention.admin.modules.lookup(server_module, co, lo, scope='sub', superordinate=superordinate, base=baseDN,
														 filter=univention.admin.filter.expression('cn', dccn))
			is_slave = len(slaveobjs) > 0

			if dcName:
				# manual dc name has been specified by user

				if not is_master_or_backup and not is_slave:
					print 'WARNING: given system name %s is already in use and no domaincontroller system. Please choose another name' % dcName
					sys.exit(1)

				if is_master_or_backup and is_slave:
					print 'ERROR: implementation error: %s seems to be dc slave and dc master at the same time' % dcName
					sys.exit(1)

				if len(slaveobjs) > 1:
					print 'ERROR: more than one system with cn=%s found' % dcName
					sys.exit(1)

				if is_slave:
					obj = slaveobjs[0]
					obj.open()
					for dcgroup in dcgroups:
						if dcgroup not in obj["groups"]:
							obj["groups"].append(dcgroup)
					modify_object(obj)

		if not server_exists:
			position.setDn("cn=dc,cn=server,cn=computers,"+getDN (schoolNr))
			object=server_module.object(co, lo, position=position, superordinate=superordinate)
			count_lo()
			object.open()
			object["name"]=dccn
			object["unixhome"]="/dev/null"
			object["shell"]="/bin/bash"
			object["primaryGroup"]="cn=DC Slave Hosts,cn=groups,%s"%baseDN
			for dcgroup in dcgroups:
				if dcgroup not in object["groups"]:
					object["groups"].append (dcgroup)
			try:
				create_object(object)
			except:
				pass
			print "need to create server: %s"%object.dn

		# create dhcp-service if not exsistant
		objects = univention.admin.modules.lookup(dhcp_service_module, co, lo, scope='sub', superordinate=superordinate, base=baseDN,
												  filter=univention.admin.filter.expression('cn', schoolNr.lower ()))
		count_lo()
		service_exists=0
		if objects:
			service = "cn=%s,cn=dhcp,%s"%(schoolNr.lower (), getDN (schoolNr))
			for object in objects:
				if object.dn == service:
					service_exists=1
					dhcp_service_object=object
		if not service_exists:
			position.setDn("cn=dhcp,%s" % (getDN (schoolNr), ))
			object=dhcp_service_module.object(co, lo, position=position, superordinate=superordinate)
			count_lo()
			object.open()
			object["service"]=schoolNr.lower ()
			try:
				create_object(object)
			except:
				pass
			dhcp_service_object=object
			print "need to create dhcp service: %s"%object.dn

		# create dhcp-server if not exsistant
		objects = lo.searchDn( filter = '(&(objectClass=dhcpServer)(cn=%s))' % dccn, base=baseDN )
		count_lo()
		if objects:
			# move existing dhcp server object to OU
			newDHCPServerDN = "cn=%s,cn=%s,cn=dhcp,%s" % (dccn, schoolNr.lower(), getDN(schoolNr))
			if len(objects) > 1:
				print 'WARNING: more than one dhcp-server object found! Moving only one!'
			obj = univention.admin.objects.get(dhcp_service_module, co, lo, position='', dn=objects[0], arg='')
			obj.open()
			if obj.dn != newDHCPServerDN:
				move_object(obj, newDHCPServerDN)
		else:
			# create fresh dhcp server object
			position.setDn("cn=%s,cn=dhcp,%s"%(schoolNr.lower (), getDN (schoolNr)))
			object=dhcp_server_module.object(co, lo, position=position, superordinate=dhcp_service_object)
			count_lo()
			object.open()
			object["server"]=dccn
			print "need to create dhcp server: %s" % object.dn
			try:
				create_object(object)
			except:
				pass

		# create userlogon-share if not existant
		objects = univention.admin.modules.lookup(share_module, co, lo, \
				scope='sub', superordinate=superordinate, \
				base='cn=shares,%s' % ( getDN(schoolNr)), \
				filter=univention.admin.filter.expression('cn','userlogon'))
		count_lo()
#		if objects:
#			share = "cn=userlogon,cn=shares,%s" % (getDN(schoolNr), )
#			for object in objects:
#				if object.dn == share:
#					share_exists=1
		if not objects:
			position.setDn("cn=shares,%s" % (getDN(schoolNr), ))
			object=share_module.object(co, lo, position=position)
			count_lo()
			object.open()
			object.options=['samba']
			object["name"]="userlogon"
			object["host"]=dccn
			object['path']='/var/lib/samba/userlogon'
			try:
				create_object(object)
			except:
				pass
			print "need to create share: %s"%object.dn

	if not schoolNr in verified_ous:
		verified_ous.append(schoolNr)

	# attach policies if needed
	for containerdn in container_policies.keys():
		# verify for each container that container does exist
		verify_container('%s,%s' % (containerdn,ou_base), cn_module, co, lo, superordinate, baseDN, '')
		pollist = container_policies[containerdn]

		# test if all policy objects exist and if all referenced objects are policy objects
		for poldn in pollist:
			oc = lo.get( poldn, ['objectClass'] )
			if not oc:
				print "Object to be referenced does not exist: " + poldn
				problem_hints = problem_hints + "there were problems verifying this ou %s\n" % schoolNr
				break
			elif not 'univentionPolicy' in oc['objectClass']:
				print "Object to be referenced is no valid policy: " + poldn
				problem_hints = problem_hints + "there were problems verifying this ou %s\n" % schoolNr
				break
		else:
			# add univentionPolicyReference if neccessary
			oc = lo.get( '%s,%s' % (containerdn,ou_base), ['objectClass'] )
			if not 'univentionPolicyReference' in oc.get('objectClass',[]):
				lo.modify('%s,%s' % (containerdn,ou_base), [ ('objectClass','','univentionPolicyReference') ] )
			# add all missing policies
			pl = lo.get( '%s,%s' % (containerdn,ou_base), ['univentionPolicyReference'] )
			modlist=[]
			for poldn in pollist:
				if not poldn in pl.get('univentionPolicyReference',[]):
					modlist.append(('univentionPolicyReference','',poldn))
					print 'need to attach policy: %s' % poldn
			lo.modify('%s,%s' % (containerdn,ou_base),modlist)

	# invoke post hooks
	if created:
		# for OUs the temporary file contains the LDAP DN
		hooks.post( 'ou', 'A', dn = ou_base, line = myline )

def create_sub_object(o):
	# create a user object without mailPrimaryAddress but with
	# univentionAbordnung objectclass and univentionAbordnungMasterDn
	# with dn of the user who has the same mailPrimaryAddress

	# univentionAbordnungMasterDn
	mail = o['mailPrimaryAddress']
	o['mailPrimaryAddress'] = []
	ml = []

	# create sub account without mailPrimaryAddress
	dn = o.create()

	# search mailPrimaryAddress
	result = o.lo.search(filter='(&(objectClass=univentionMail)(objectClass=posixAccount)(mailPrimaryAddress=%s))' % mail, attr=['mailPrimaryAddress'])
	superdn, attrs = result[0]

	# append objectclass and attribut to sub account
	ml.append(('objectClass', None, "univentionAbordnung"))
	ml.append(("univentionAbordnungMasterDn", None, superdn))
	try:
		o.lo.modify(dn, ml)
	except:
		problem_hints = "problems while setting univentionAbordnung to " + dn + "\n"


def move_object(o, newdn):
	if o.dn == newdn:
		return

	try:
		print 'moving object: old DN=%s   new DN=%s' % (o.dn, newdn)
		o.move(newdn)
	except univention.admin.uexceptions.noObject:
		print "ERROR while moving object %s: object not found" % o.dn
		print 'ERROR:', sys.exc_info()[0], sys.exc_info()[1]
		traceback.print_exc(100, sys.stdout)
	except univention.admin.uexceptions.ldapError:
		print "ERROR while moving object %s: ldap error" % o.dn
		print 'ERROR:', sys.exc_info()[0], sys.exc_info()[1]
		traceback.print_exc(100, sys.stdout)
	except univention.admin.uexceptions.invalidOperation, msg:
		print "ERROR while moving object %s: invalid operation: %s" % (o.dn, msg)
		print 'ERROR:', sys.exc_info()[0], sys.exc_info()[1]
		traceback.print_exc(100, sys.stdout)


def modify_object(o):
	try:
		dn = o.modify()
		print 'modifed object:', o.dn
	except:
		print "ERROR while modifying object %s" % o.dn
		print 'ERROR:', sys.exc_info()[0], sys.exc_info()[1]
		traceback.print_exc(100, sys.stdout)


def create_object( o, ignore_exists = False ):
	exists = False
	msg = ''
	dn = None
	try:
		dn=o.create()
		print 'creating object', dn
	except univention.admin.uexceptions.objectExists:
		if not ignore_exists:
			msg = 'ERROR: Object exists-1 (objectExists)'
		else:
			exists = True
	except univention.admin.uexceptions.uidAlreadyUsed:
		if not ignore_exists:
			msg = 'ERROR: Object exists-2 (uidAlreadyUsed)'
		else:
			exists = True
	except univention.admin.uexceptions.dhcpServerAlreadyUsed:
		if not ignore_exists:
			msg = 'ERROR: Object exists-3 (dhcpServerAlreadyUsed)'
		else:
			exists = True
	except univention.admin.uexceptions.noLock:
		if not ignore_exists:
			msg = 'ERROR: Object exists-4 (noLock)'
		else:
			exists = True
	except univention.admin.uexceptions.mailAddressUsed:
		create_sub_object(o)

	if msg:
		print msg
		traceback.print_exc (100, sys.stdout)
		raise CreateObjectError( exists, dn )

	return ( exists, dn )


def verify_containers (position_dn, module, co, lo, superordinate, base, path=""):
	"""
	verifies all containers starting at the ldap base

	@param	module	Param is ignored! cn_module is the only supported module!!
	"""
	split_dn = position_dn.split (',')
	# with this variable it's ensured that within a row of containers there is
	# no other object/container which can not be created with method
	started_cn_row = False
	for i in xrange (len (split_dn) -1, -1, -1):
		if split_dn[i].startswith ('cn='):
			verify_container (','.join (split_dn[i:]), cn_module, co, lo, superordinate, base, path=path)
			started_cn_row = True
		elif started_cn_row:
			# found an object/container that can not be created
			break

def verify_container(position_dn, module, co, lo, superordinate, base, path="userPath"):
	"""
	look if goal-container exists, else create it
	"""
	container_exists = 0
	type=position_dn[0:string.find(position_dn,"=")]
	name=position_dn[string.find(position_dn,"=")+1:string.find(position_dn,",")]
	position=position_dn[string.find(position_dn,",")+1:]
	objects=''
	try:
		objects = univention.admin.modules.lookup(module, co, lo, scope='sub', superordinate=superordinate, base=position,
												  filter=univention.admin.filter.expression(type,name))
		count_lo()
	except:
		pass
	if objects:
		for object in objects:
			if codecs.latin_1_encode(univention.admin.objects.dn(object))[0]==position_dn:
				container_exists = 1

	created = False
	dn = None
	if not container_exists:
		print "need to create container %s"%position_dn
		position=univention.admin.uldap.position(base)
		position.setDn(position_dn[string.find(position_dn,",")+1:])
		object = module.object(co, lo, position, superordinate=superordinate)
		count_lo()
		object.open()
		object["name"] = position_dn[3:string.find(position_dn,",")]

		if position_dn[:2] == "cn" and path: # is path container
			object[path] = codecs.latin_1_encode("1")[0]

		try:
			exists, dn = create_object(object)
			created = True
		except CreateObjectError, e:
			exists, dn = e.args

	return ( created, dn )

def verify_group_share(schoolNr, classNr, co, lo, superordinate, base):

	if (schoolNr, classNr.lower()) in verified_group_shares:
		return True

	position_dn="cn=%s,cn=klassen,cn=shares,%s"%(classNr, getDN (schoolNr, basedn=base))
	module = univention.admin.modules.get("shares/share")
	position_basedn = univention.admin.uldap.position(baseDN)
	univention.admin.modules.init (lo, position_basedn, module)
	more_instances = 1
	container_position = base
	while more_instances:
		container_position = position_dn[string.rfind(position_dn,",",0,len(position_dn)-len(container_position)-1)+1:]
		if container_position == position_dn:
			more_instances = 0
		elif container_position[:2] == "cn":
			verify_container(container_position, cn_module, co, lo, superordinate, base, path="groupPath")
		elif container_position[:2] == "ou":
			verify_container(container_position, ou_module, co, lo, superordinate, base)
		else: print "WARNING: unknown container type",container_position

	# look if share exists, else create it
	share_exists = 0
	type=position_dn[0:string.find(position_dn,"=")]
	name=position_dn[string.find(position_dn,"=")+1:string.find(position_dn,",")]
	position=position_dn[string.find(position_dn,",")+1:]
	objects = univention.admin.modules.lookup(module, co, lo, scope='sub', superordinate=superordinate, base=position,
											  filter=univention.admin.filter.expression(type,name))
	count_lo()
	if objects:
		for object in objects:
			if codecs.latin_1_encode(univention.admin.objects.dn(object))[0].lower() == position_dn.lower():
				share_exists = 1
	if not share_exists:
		print "need to create groupshare %s"%position_dn

		# get gid form corresponding group
		group_dn="cn=%s,cn=klassen,cn=%s,cn=groups,%s"%(classNr, cn_pupils, getDN (schoolNr, basedn=base))
		gids=lo.get(group_dn,['gidNumber'])
		count_lo()
		gid = 0
		if len(gids) > 1:
			print "WARNING: more than one corresponding gid found"
			gid=gids["gidNumber"][0]
		elif len(gids) < 1:
			print "WARNING: no corresponding gid found"
		else:
			gid=gids["gidNumber"][0]


		# set default server
		serverfqdn = "dc%s-01.%s"%(schoolNr.lower (),domainname)

		# get alternative server (defined at ou object if a dc slave is responsible for more than one ou)
		ou_dn = getDN (schoolNr, basedn=base)
		ou_attr_LDAPAccessWrite = lo.get(ou_dn,['univentionLDAPAccessWrite'])
		count_lo()
		alternativeServer_dn = None
		if len(ou_attr_LDAPAccessWrite) > 0:
			alternativeServer_dn = ou_attr_LDAPAccessWrite["univentionLDAPAccessWrite"][0]
			if len(ou_attr_LDAPAccessWrite) > 1:
				print "WARNING: more than one corresponding univentionLDAPAccessWrite found at ou=%s" % schoolNr

		# build fqdn of alternative server and set serverfqdn
		if alternativeServer_dn:
			alternativeServer_attr = lo.get(alternativeServer_dn,['uid'])
			count_lo()
			if len(alternativeServer_attr) > 0:
				alternativeServer_uid = alternativeServer_attr['uid'][0]
				alternativeServer_uid = alternativeServer_uid.replace('$','')
				if len(alternativeServer_uid) > 0:
					serverfqdn = "%s.%s" % (alternativeServer_uid, domainname)


		position=univention.admin.uldap.position(base)
		position.setDn(position_dn[string.find(position_dn,",")+1:])
		object = module.object(co, lo, position, superordinate=superordinate)
		count_lo()
		object.open()
		object["name"] = "%s"%classNr
		object["host"] = serverfqdn
		object["path"] = "/home/groups/klassen/%s"%classNr
		object["writeable"] = "1"
		object["sambaWriteable"] = "1"
		object["sambaBrowseable"] = "1"
		object["sambaForceGroup"] = "+%s"%classNr
		object["sambaCreateMode"] = "0770"
		object["sambaDirectoryMode"] = "0770"
		object["owner"]="0"
		object["group"]=gid
		object["directorymode"]="0770"

		try:
			create_object(object)
		except:
			pass

	if not classNr in verified_group_shares:
		verified_group_shares.append((schoolNr, classNr.lower()))


def verify_group(position_dn, co, lo, superordinate, base):
	# look if group exists, else create it

	if position_dn in verified_groups:
		return True

	group_exists = 0
	type=position_dn[0:string.find(position_dn,"=")]
	name=position_dn[string.find(position_dn,"=")+1:string.find(position_dn,",")]
	position=position_dn[string.find(position_dn,",")+1:]

	more_instances = 1
	container_position = base
	while more_instances:
		container_position = position_dn[string.rfind(position_dn,",",0,len(position_dn)-len(container_position)-1)+1:]
		if container_position == position_dn:
			more_instances = 0
		elif container_position[:2] == "cn":
			verify_container(container_position, cn_module, co, lo, superordinate, base, path="groupPath")
		elif container_position[:2] == "ou":
			verify_container(container_position, ou_module, co, lo, superordinate, base)
		else: print "WARNING: unknown container type",container_position

	objects = univention.admin.modules.lookup(group_module, co, lo, scope='sub', superordinate=superordinate, base=position,
											  filter=univention.admin.filter.expression(type,name))
	count_lo()
	if objects:
		for object in objects:
			if codecs.latin_1_encode(univention.admin.objects.dn(object))[0].lower() == position_dn.lower():
				group_exists = 1

	if not group_exists:
		print "need to create group %s"%position_dn
		position=univention.admin.uldap.position(base)
		position.setDn(position_dn[string.find(position_dn,",")+1:])
		object = group_module.object(co, lo, position, superordinate=superordinate)
		count_lo()
		object.open()
		object["name"] = position_dn[3:string.find(position_dn,",")]


		try:
			create_object(object)
		except:
			pass

	if not position_dn in verified_groups:
		verified_groups.append(position_dn)

def delete_dn(dn, module, co, lo):
	position.setDn(dn[string.find(dn,",")+1:])
	object=univention.admin.objects.get(module, co, lo, position=position, dn=dn)
	count_lo()
	object.open()
	try:
		object.remove()
		print "deleted:",dn
		return True
	except univention.admin.uexceptions.noObject:
		message = 'ERROR: delete this user manually (not found): ' + dn
	except:
		message = 'ERROR: delete this user manually (maybe not found):' + dn

	print message
	traceback.print_exc( 100, sys.stdout )
	raise DeleteObjectError( message )

def delete_user(person, module, co, lo):

	# search all objects with univentionAbordnungMaster == dn of the person
	# we want to delete, make one of them to the new master account
	# (set primaryMailAddress and remove univentionAbordnungMaster attribute
	# and univentionAbordnung objectclass) and change dn in univentionAbordnungMaster
	# in the rest
	dn = person.getDN()
	mail = person.mail
	base = person.getPosition_dn()
	uid = person.login
	newdn = ""
	success = True

	# get primaryMail from account
	master = lo.search(base=base, filter="(uid=%s)" % uid, attr=['mailPrimaryAddress'])
	if master:
		tmpdn, attr = master[0]
		if attr.has_key("mailPrimaryAddress") and attr['mailPrimaryAddress']:
			mail = attr['mailPrimaryAddress']

	# delete account
	try:
		delete_dn(person.getDN(),module,co,lo)
	except DeleteObjectError, e:
		person.problem_hints += str( e ) + '\n'
		success = False

	# search sub accounts
	result = lo.search(filter='(univentionAbordnungMasterDn=%s)' % dn, attr=['objectClass'])

	# first sub account becomes new master account
	if result:
		newdn, attr = result[0]
		ocs = []
		for i in attr['objectClass']:
			if not i == "univentionAbordnung": ocs.append(i)
		ml = []
		ml.append(('objectClass', attr['objectClass'], ocs))
		ml.append(("mailPrimaryAddress", None, mail))
		ml.append(("univentionAbordnungMasterDn", dn, ""))
		try:
			lo.modify(newdn, ml)
		except:
			person.problem_hints += "problems while making " + newdn + " a master account\n"
		del result[0]

	# modify sub accounts
	for i in result:
		subdn, attr = i
		ml = []
		ml.append(("univentionAbordnungMasterDn", dn, newdn))
		try:
			lo.modify(subdn, ml)
		except:
			person.problem_hints += "problems while setting new master dn to sub account " + subdn + "\n"

	return success

def modify_user(person, module, co, lo):
	default_groups = person.default_groups()
	object=univention.admin.objects.get(module, co, lo, position='', dn=person.getDN(), arg='')
	count_lo()
	object.open()
	object["username"]=person.login
	object["primaryGroup"]=default_groups[0]
	object["unixhome"]="/home/"+person.login
	object["firstname"]=person.name
	object["lastname"]=person.sname
	object["e-mail"]=person.mail
	if object.has_key('mailPrimaryAddress'):
		object['mailPrimaryAddress']=person.mail
	if person.isActive == "1":
		object["disabled"]="0"
	else:
		object["disabled"]="1"
	# ATTENTION: it's not possible to change the ucsschool-user-role with the
	# import script

	remove_groups = []
	for group in object['groups']:
		if group not in default_groups:
			parts = univention.admin.uldap.explodeDn( group )
			if len(parts) <= 2:
				continue

			# FIXME / TODO
			# Test should be following:
			# if ( ( ( parts[0].startswith( 'cn=%s' % grp_prefix_pupils) or parts[0].startswith( 'cn=%s' % grp_prefix_pupils) ) and parts[1] == 'cn=groups' and parts[2].startswith('ou=') ) or
			# 	 ( parts[1] == 'cn=klassen' and parts[2] == 'cn=%s' % cn_pupils and parts[3] == 'cn=groups' and parts[4].startswith('ou=') ) ):

			if ( parts[0].startswith( 'cn=%s' % grp_prefix_pupils ) or
				 parts[0].startswith( 'cn=%s' % grp_prefix_teachers ) or
				 ( parts[1] == 'cn=klassen' and parts[2] == 'cn=%s' % cn_pupils ) ):
				# group looks like a default group, so we don't need it anymore
				print "remove from group: %s"%group
				remove_groups.append(group)
	for group in remove_groups:
		object['groups'].remove(group)

	for group in default_groups:
		if group not in object["groups"]:
			object["groups"].append(group)
			verify_group(group, co, lo, superordinate, baseDN)
			print "need to add group %s"%group

	#print "user is in groups: %s" % object['groups']

	for cnr in person.cNr:
		verify_group_share(person.sNr,cnr,co,lo,superordinate,baseDN)

	try:
		object.modify()
		o_sNr=lo.search(base=person.getDN(), scope='base', attr=['departmentNumber'])
		count_lo()
		if not o_sNr == person.allsNrs:
			lo.modify(person.getDN(),[("departmentNumber",o_sNr,person.allsNrs)])
			count_lo()
		print "modified:",person.getDN()
	except:
		print "ERROR:", sys.exc_info()[0], sys.exc_info()[1]
		traceback.print_exc (100, sys.stdout)
		print "modify this user manually:",person.getDN()
		person.problem_hints = person.problem_hints + "modify this user manually: "+person.getDN()+"\n"


def check_user(person, baseDN, module):
	objects = univention.admin.modules.lookup(module, co, lo, scope='sub', superordinate=superordinate, base=person.getPosition_dn(),
											  filter=univention.admin.filter.expression('uid',person.login))
	count_lo()
	user_exists=0
	if objects:
		for object in objects:
			if object.dn == person.getDN():
				user_exists = 1
	return user_exists

def get_passwd():
	makepasswd = os.popen('makepasswd --chars=8')
	return makepasswd.readline().strip('\r\n') # without newline

def create_passwd():
	charlistA = 'abcdefghijklmnopqrstuvwxyz'
	charlistB = '0123456789'
	passwd=''
	passwd += charlistA[ random.randrange(0,len(charlistA)) ] + charlistA[ random.randrange(0,len(charlistA)) ]
	passwd += charlistB[ random.randrange(0,len(charlistB)) ] + charlistB[ random.randrange(0,len(charlistB)) ]
	passwd += charlistA[ random.randrange(0,len(charlistA)) ] + charlistA[ random.randrange(0,len(charlistA)) ]
	passwd += charlistB[ random.randrange(0,len(charlistB)) ] + charlistB[ random.randrange(0,len(charlistB)) ]
	return passwd

def create_user(person, baseDN, module, password):
	success = True

	if generate_logins:
		try:
			loginname = person.login
			i = 1
			while(check_user(person, baseDN, user_module)):
				print "WARING: User already exists: %s"%person.getDN()
				person.problem_hints +="WARNING: Username already exists: %s" % person.getDN()+" appended counted number\n"
				person.login = loginname+str(i)
				print "INFO: Trying with new username: ", person.login
				i = i+1
		except: # happens if container does not exsist
			pass

	# check if ou exists at all
	objects = univention.admin.modules.lookup(ou_module, co, lo, scope='sub', superordinate=superordinate, base=baseDN,
										  filter=univention.admin.filter.expression('ou',person.sNr))
	count_lo()
## 	ou_exists=0
## 	if objects:
## 		for object in objects:
## 			if codecs.latin_1_encode(univention.admin.objects.dn(object))[0]==(getDN (person.sNr)):
## 				ou_exists = 1
## 	if not ou_exists:
	verify_school_ou(person.sNr, co, lo, baseDN)
	# check if needed subtree exists, this should not be neccessary be after verify of the ou but we may crash if someone makes changes by hand
	more_instances = 1
	container_position = baseDN
	while more_instances:
		container_position = person.getPosition_dn()[string.rfind(person.getPosition_dn(),",",0,
															  len(person.getPosition_dn())-len(container_position)-1)+1:]
		if container_position == person.getPosition_dn():
			more_instances = 0
		if container_position[:2] == "cn":
			verify_container(container_position, cn_module, co, lo, superordinate, baseDN)
		elif container_position[:2] == "ou":
			verify_container(container_position, ou_module, co, lo, superordinate, baseDN)
		else: print "WARNING: unknown container type",container_position


	groups = person.default_groups()
	for group in groups:
		verify_group(group, co, lo, superordinate, baseDN)
	for cnr in person.cNr:
		verify_group_share(person.sNr,cnr,co,lo,superordinate,baseDN)

	position=univention.admin.uldap.position(baseDN)
	position.setDn(person.getPosition_dn())

	object=user_module.object(co, lo, position=position, superordinate=superordinate)
	count_lo()
	object.open()

	object["username"]=person.login
	object["primaryGroup"]=groups[0]
	if len(groups) > 1:
		object["groups"]=groups[1:]
	object["unixhome"]="/home/"+person.login
	if object.has_key('mailbox'):
		object["mailbox"]="/var/spool/%s/"%person.login
	object["password"]=password
	object["firstname"]=person.name
	object["lastname"]=person.sname
	object["e-mail"]=person.mail
	if object.has_key('mailPrimaryAddress'):
		object['mailPrimaryAddress']=person.mail
	if person.isActive == "1":
		object["disabled"]="0"
	else:
		object["disabled"]="1"
#	object["ucsschool-user-role"] = person.getRole ()
	object["pwdChangeNextLogin"]="0"

	try:
		try:
			exists, dn = create_object(object)
		except CreateObjectError, e:
			exists, dn = e.args
			success = False
		if not exists:
			lo.modify(person.getDN(),[("departmentNumber",[],person.allsNrs)])
			count_lo()
			print "created:",person.getDN()
			created_users[person.login]=password
		else:
			print "ERROR: there were problems creating this user:",person.getDN()
			person.problem_hints = person.problem_hints + "ERROR: there were problems creating this user: "+person.getDN()+"\n"

	except:
		print "ERROR:", sys.exc_info()[0], sys.exc_info()[1]
		print "ERROR: create this user manually:",person.getDN()
		traceback.print_exc (100, sys.stdout)
		person.problem_hints = person.problem_hints + "ERROR: create this user manually: " + person.getDN()+"\n"

	return success

def import_user():
	# argument is infile
	if len(sys.argv)>1:
		infile = sys.argv[1]
	else:
		print "must have one Argument for infile"
		sys.exit()

	print "infile is  : "+infile
	inf = open(infile,'r')

	# outfile for passwords of created users
	outfile = None
	#outfile = "/var/lib/ucs-school-import/create-user-passwd-%s.csv" % time.strftime("%Y%m%d-%H%M%S")
	#outf = open(outfile,'w')

#	if len(sys.argv)>2:
#		outfile = sys.argv[2]
#		print "outfile is : ./"+outfile
#		if os.path.exists(outfile):
#			print 'outfile %s does already exist. Stopping here.' % outfile
#			sys.exit()
#		outf = open(outfile,'w')

	problem_hints=""
	passwd_used=1
	linecnt=0

	line=inf.readline()
	while not line=="":
		linecnt += 1
		print 'Processing line %d: %s' % (linecnt, line),
		try:
			main_person = ucsschool_person_modify(line)
		except:
			msg = 'ERROR: Problems parsing line, skipped: %d: %s' % (linecnt, line)
			print msg
			traceback.print_exc (100, sys.stdout)
			problem_hints += msg + '\n'
			## read next line
			line = inf.readline()
			continue

		persons = [main_person]
		persons.extend(main_person.getOtherPersons())
		passwd = create_passwd()
		#passwd = get_passwd()
		#passwd = '12345678'

		# invoke pre hooks
		hooks.pre( 'user', main_person.modtype, line = line )
		# variable to store success of operation and LDAP dn
		success = True
		dn = None
		if main_person.modtype == "A":
			#if passwd_used:
			#	passwd=''
			#	passwd_used=0
			for person in persons:
				try:
					#if passwd=='':
					#	create password, only if not already done. So one user has the same initial passwd in all his accounts
					#	passwd=get_passwd()
					#	passwd_used=0
					#if create_user(person, baseDN, user_module, passwd):
					#	passwd_used=1
					result = create_user(person, baseDN, user_module, passwd)
					if result and outfile:
						outf.write('%s\t%s\t%s\t%s\t%s\t%s\t%s\n' % (person.sNr, ','.join(person.cNr), person.sname, person.name, passwd, person.mail, person.login))
					success = result
				except:
					msg = "ERROR: There were problems creating this user: " + str(person.getDN())
					print msg
					traceback.print_exc (100, sys.stdout)
					person.problem_hints += msg + "\n"
					success = False
				if not dn:
					dn = person.getDN()
		elif main_person.modtype in ["M","D"]:
			# look if there are exsiting persons in other ou's remaining, this will fail if the users's departmentNumbers
			# are changed manually
			filter=univention.admin.filter.conjunction("|",[univention.admin.filter.expression('uid',"%s_*"%main_person.login),
															univention.admin.filter.expression('uid',"%s"%main_person.login)])
			objects = univention.admin.modules.lookup(user_module, co, lo, scope='sub', superordinate=superordinate, base=baseDN,
											  filter=filter)
			count_lo()
			found = []
			for object in objects:
				ou=object.dn[string.find(object.dn,"ou=")+3:string.find(object.dn,",",string.find(object.dn,"ou=")+3)]
				# get from LDAP the user type: teacher, staff or student
# 				main_person.isTeacher = '0'
# 				main_person.isStaff   = '0'
# 				if role_teacher in object['ucsschool-user-role']:
# 					main_person.isTeacher = '1'
# 				if role_staff in object['ucsschool-user-role']:
# 					main_person.isStaff = '1'

				if ou in main_person.allsNrs:
					found.append(ou)
				else:
					main_person.problem_hints += "delete unmentioned user %s \n"%object.dn
					try:
						delete_dn(object.dn,user_module,co,lo)
					except DeleteObjectError, e:
						success = False
						main_person.problem_hints += str( e ) + '\n'

			for person in persons:
				if person.modtype == "M":
					if person.sNr in found:
						try:
							modify_user(person, user_module, co, lo)
						except:
							msg = "ERROR: There were problems modifying this user: "  + str(person.getDN())
							print msg
							traceback.print_exc (100, sys.stdout)
							person.problem_hints += msg + "\n"
							success = False
					else:
						try:
							print "WARNING: user to modify not found, ",
							result = create_user(person, baseDN, user_module, passwd)
							if result and outfile:
								outf.write('%s\t%s\t%s\t%s\t%s\t%s\t%s\n' % (person.sNr, ','.join(person.cNr), person.sname, person.name, passwd, person.mail, person.login))
						except:
							msg = "ERROR: There were problems creating this user: "  + str(person.getDN())
							print msg
							traceback.print_exc (100, sys.stdout)
							person.problem_hints += msg + "\n"
							success = False

				else: # main_person.modtype == "D":
					# NOTE: there is no need for this try-catch-block because delete_dn handles exceptions by itself
					#try:
					success = delete_user(person, user_module, co, lo)
					#except:
						#msg = "There were problems deleting this user:" , person.getDN()
						#print msg
						#traceback.print_exc (100, sys.stdout)
						#person.problem_hints += msg + "\n"

				if not dn:
					dn = person.getDN()
				main_person.problem_hints += person.problem_hints
		else:
			print "WARNING: unknown operation type:",main_person.modtype
			main_person.problem_hints += "unknown operation type for this user: "+main_person.getDN()+"\n"
			success = False

		problem_hints += main_person.problem_hints
		# invoke post hooks on success
		if success:
			hooks.post( 'user', main_person.modtype, dn = dn, line = line )

		#print 'Processing of line %d completed' % linecnt

		# read next line
		line=inf.readline()

	if outfile:
		outf.close()

	# report created users
	message=""
	#if not created_users.keys() == []:
	#	message = "The following Users/Passwords were created. Please change the Password immediatly !\n\n\n"
	#	for el in created_users.keys():
	#		message = message+ el + " - " + created_users[el] +"\n"

	if not problem_hints == "":
		message = message + "\n\nProblems during last run:\n\n" + problem_hints

	print message

def create_network(schoolNr, network, iprange=None, defaultrouter=None, nameserver=None, netbiosserver=None):
	"""
	@param	network	The network address MUST contain the netmask!! it could also be a ipaddr.IPv4 object
	@param	defaultrouter	IP-Adress, if no netmask is profided it's derived from network
	@param	nameserver	IP-Adress, if no netmask is profided it's derived from network
	@param	netbiosserver	IP-Adress, if no netmask is profided it's derived from network
	"""
	success = True
	dn = None
	verify_school_ou(schoolNr, co, lo, baseDN)


	if check_network(schoolNr, network):
		print "Network %s/%d exists in school %s!"%(network.network_ext, network.prefixlen, schoolNr)
		return ( False, dn )

	print "generate network %s/%d" % (network.network_ext, network.prefixlen)
	if iprange:
		print "iprange: %s-%s" % (iprange[0].ip_ext, iprange[1].ip_ext)
	if defaultrouter:
		print "defaultrouter: %s" % defaultrouter
	if nameserver:
		print "nameserver: %s" % nameserver
	if netbiosserver:
		print "netbiosserver: %s" % netbiosserver

	# WORKAROUND for Bug #14795
	subnetbytes = 0
	tmp = network.netmask_ext.split ('.')
	for i in tmp:
		if i == '255':
			subnetbytes += 1
		else:
			break
	subnet = '.'.join (network.network_ext.split ('.')[:subnetbytes])
	# END WORKAROUND

	position.setDn("cn=dns,%s"%(baseDN))
	object=dns_reverse_zone_module.object(co, lo, position=position, superordinate=superordinate)
	count_lo()
	object.open()
	object['subnet']     = subnet
	# the nameserver/SOA at the dns_reverse_zone object is always the ldap/master server!
	object['nameserver'] = configRegistry['ldap/master']
	object['contact']    = 'root@%s'%domainname
	try:
		create_object( object, ignore_exists = True )
	except:
		pass

	position.setDn("cn=%s,cn=dhcp,%s"%(schoolNr.lower (), getDN (schoolNr)))
	object=dhcp_service_module.object(co, lo, position=position, superordinate=superordinate)
	count_lo()
	object=dhcp_subnet_module.object(co, lo, position=position, superordinate=dhcp_subnet_module)
	count_lo()
	object.open()
	object['subnet']=network.network_ext
	object['subnetmask']=network.netmask_ext
	object['broadcastaddress']=network.broadcast_ext
	try:
		create_object( object )
	except:
		success = False

	position.setDn("cn=networks,%s" % (getDN (schoolNr), ))
	object=network_module.object(co, lo, position=position, superordinate=superordinate)
	count_lo()
	object.open()
	object['name']='%s-%s'%(schoolNr.lower (), network.network_ext)
	object['netmask']=str (network.prefixlen)
	object['network']=network.network_ext
	if iprange:
		object['ipRange']=[[iprange[0].ip_ext, iprange[1].ip_ext]]
	object['dhcpEntryZone']='cn=%s,cn=dhcp,%s'%(schoolNr.lower (), getDN (schoolNr))
	object['dnsEntryZoneForward']='zoneName=%s,cn=dns,%s'%(domainname, baseDN)
	object['dnsEntryZoneReverse']='zoneName=%s.in-addr.arpa,cn=dns,%s'%('.'.join (reversed (subnet.split ('.'))),baseDN)

	try:
		exists, dn = create_object( object )
	except:
		success = False

	# set netbios and router for dhcp subnet
	if defaultrouter:
		print 'setting default router'
		set_router_for_subnet (network, defaultrouter, schoolNr)

	if netbiosserver:
		print 'setting netbios server'
		set_netbiosserver_for_subnet (network, netbiosserver, schoolNr)

	# set default value for nameserver
	if nameserver:
		print 'setting nameserver'
		set_nameserver_for_subnet (network, nameserver, schoolNr)

	return ( success, dn )

def check_network(schoolNr, network):
	"""
	@param	network	ipaddr.IPv4 object
	"""
	objects = univention.admin.modules.lookup(network_module, co, lo, scope='sub', superordinate=superordinate,
											  base='cn=networks,%s'%(getDN (schoolNr)),
											  filter=univention.admin.filter.expression('cn','%s-%s'%(schoolNr.lower (), network.network_ext)))
	count_lo()
	network_exists=0
	if objects:
		n = "cn=%s-%s,cn=networks,%s"%(schoolNr.lower (), network.network_ext, getDN (schoolNr))
		for object in objects:
			if object.dn == n:
				network_exists = 1

	return network_exists

def check_macAddress(mac,base=''):
	if not base:
		base=baseDN
	result=lo.search(base=base, scope='sub',filter='(macAddress=%s)'%mac,attr=['macAddress'])
	count_lo()

	if result and result[0][1]['macAddress'][0]==mac:
		return result[0][0]

def generate_new_mac(schoolNr,IP):
	ipnum=string.replace(IP,'.','')
	if IP:
		mac_start = '%s:%s:%s:%s:'%(schoolNr[:2],schoolNr[-2:],ipnum[:2],ipnum[-2:])
	else:
		# FIXME: following line seems to be broken
		mac_start = '%s:%s:00:00:'%(schoolNr[:2],schoolNr[-2:],ipnum[:2],ipnum[-2:])
	mac='%s00:00'%mac_start
	i=10
	j=10
	while check_macAddress(mac,base='cn=computers,%s' % (getDN (schoolNr), )):
		if i==99:
			i=10
			j+=1
		else:
			i+=1
		mac='%s%s:%s'%(mac_start,i,j)

	return mac

def check_computer(module, name, schoolNr):
	objects = univention.admin.modules.lookup(module, co, lo, scope='sub', superordinate=superordinate,
											  base='cn=computers,%s' % (getDN (schoolNr), ),
											  filter=univention.admin.filter.expression('cn','%s'%name))
	count_lo()
	computer_exists=0
	if objects:
		for object in objects:
			if object.dn == "cn=%s,cn=computers,%s"%(name, getDN (schoolNr)):
				computer_exists = 1

	return computer_exists

def get_computer_dn(name):
	objects = univention.admin.modules.lookup(computer_module, co, lo, scope='sub', superordinate=superordinate, filter=univention.admin.filter.expression('cn','%s'%name))
	if objects:
		for object in objects:
			if object.dn.startswith("cn=%s," %name):
				return object.dn
	return None

def import_networks(router_only=False):
	# argument is infile
	if len(sys.argv)>1:
		infile = sys.argv[1]
	else:
		print "must have one Argument for infile"
		sys.exit()

	print "infile is  : "+infile
	inf = open(infile,'r')

	problem_hints=""

	line=inf.readline()
	while not line == "":
		success = True
		parsed=line.strip('\r\n').split(sepchar)

		schoolNr      = parsed[0]
		# the network MUST include the netmask
		network       = parsed[1] # netmask new
		# the broadcast address is generated automatically by the
		# combination of network and netmask
		def parseString (parsed, idx, default=None):
			res = default
			if len (parsed) > idx:
				string = parsed[idx]
				if string:
					res = string
			return res
		iprange       = parseString (parsed, 2) # new
		defaultrouter = parseString (parsed, 3) # new
		nameserver    = parseString (parsed, 4) # new
		netbiosserver = parseString (parsed, 5) # new

		# invoke pre hooks
		if router_only:
			hooks.pre( 'router', 'A', line = line )
		else:
			hooks.pre( 'network', 'A', line = line )
		dn = None
		success = True

		# convert parameters to ipaddr.IPv4
		network = ipaddr.IPv4 (network)
		if '/' not in parsed[1]:
			network.prefixlen = default_prefixlen
			print 'WARNING: no netmask specified for network %s using %s' % (network.network_ext, network.netmask_ext)

		if iprange:
			tmp = iprange.split ('-')
			if len (tmp) != 2:
				print 'ERROR: IP host range not valid: %s' % iprange
				line=inf.readline()
				continue
			iprange = (ipaddr.IPv4 (tmp[0]), ipaddr.IPv4 (tmp[1]))
			if iprange[0].ip < network.network + 1 \
					or iprange[0].ip > iprange[1].ip \
					or iprange[1].ip >= network.broadcast:
				print 'ERROR: IP host range not valid: %s-%s' % (iprange[0].ip_ext, iprange[1].ip_ext)
				line=inf.readline()
				continue
		elif network.prefixlen == 24:
			iprange = (ipaddr.IPv4 (network.ip + 20),
					ipaddr.IPv4 (network.ip + 250))

		if defaultrouter:
			defaultrouter = ipaddr.IPv4 (defaultrouter)
		if nameserver:
			nameserver = ipaddr.IPv4 (nameserver)
		if netbiosserver:
			netbiosserver = ipaddr.IPv4 (netbiosserver)

		if router_only:
			if defaultrouter:
				success, dn = set_router_for_subnet (network, defaultrouter, schoolNr, overwrite_policy=True)
				print 'Router set for subnet.'
			else:
				print 'No router specified for subnet.'
		else:
			success, dn = create_network( schoolNr, network, iprange=iprange, defaultrouter=defaultrouter, nameserver=nameserver, netbiosserver=netbiosserver )

		# invoke post hooks
		if success:
			if router_only:
				hooks.post( 'router', 'A', dn = dn, line = line )
			else:
				hooks.post( 'network', 'A', dn = dn, line = line )

		# read next line
		line=inf.readline()

def set_inventory_number_for_computer():
	# argument is infile
	if len(sys.argv)>1:
		infile = sys.argv[1]
	else:
		print "must have one Argument for infile"
		sys.exit()

	print "infile is  : "+infile
	inf = open(infile,'r')

	problem_hints=""

	line=inf.readline()
	while not line == "":

		parsed=line.strip('\r\n').split(sepchar)
		ctype    = parsed[0]
		name     = parsed[1]
		MAC      = parsed[2]
		inventoryNumbers = parsed[3].strip().split(',')

		dn = get_computer_dn(name)
		if not dn:
			print "Computer to modify not found: %s" % name
			problem_hints = problem_hints + "Computer to modify not found: %s" % name
		else:
			try:
				computerModule = univention.admin.modules.get("computers/%s"%ctype)
				position_basedn = univention.admin.uldap.position(baseDN)
				univention.admin.modules.init (lo, position_basedn, computerModule)
			except:
				print "failed to get module of type computers/%s" % ctype
				traceback.print_exc (100, sys.stdout)
				problem_hints = problem_hints + "failed to get module of type computers/%s" % ctype
				line=inf.readline()
				continue
			computerObject = univention.admin.objects.get(computerModule, co, lo, position='', dn=dn, arg='')
			computerObject.open()
			if MAC.replace('-',':').replace(' ',':').lower() in computerObject['mac']:
				try:
					computerObject['inventoryNumber'] = inventoryNumbers
					computerObject.modify()
					print "modified inventory Number for %s" % dn
				except:
					print "failed to modify computer %s" % name
					traceback.print_exc (100, sys.stdout)
					problem_hints = problem_hints + "failed to modify computer %s" % name
			else:
				print "mac address does not match while modifying %s" % name
				problem_hints = problem_hints + "mac address does not match while modifying %s" % name

		line=inf.readline()

def set_policy_for_dhcp_subnet (network, schoolNr, policy_module, policy_dn, cn, values={}, overwrite_policy=False):
	"""
	@param	network	network where policy object shall be added
	@param	schoolNr	school number
	"""
	dn = None
	success = True

	# check if routing policy needs to be created
	so = "cn=%s,cn=dhcp,%s" % (schoolNr.lower (), getDN (schoolNr))
	objects = univention.admin.modules.lookup(dhcp_subnet_module, co, lo, scope='sub', superordinate=so,
			base=baseDN, filter=univention.admin.filter.expression('cn', network.network_ext))
	count_lo()
	dhcp_subnet_object=None
	subnet = "cn=%s,cn=%s,cn=dhcp,%s" % (network.network_ext, schoolNr.lower (), getDN (schoolNr))
	if objects:
		for o in objects:
			if o.dn == subnet:
				dhcp_subnet_object = o
	if not dhcp_subnet_object:
		print "ERROR: Unable to set policy for dhcp subnet because it does not exist: %s" % subnet
		return ( False, dn )

	objects = univention.admin.modules.lookup(policy_module, co, lo, scope='sub', superordinate=superordinate,
			base=baseDN, filter=univention.admin.filter.expression('cn', cn))
	policy_object = None
	if objects:
		for o in objects:
			if o.dn == policy_dn:
				policy_object = o
	if not policy_object:
		position_dn = ','.join (policy_dn.split (',')[1:])
		verify_containers (position_dn, cn_module, co, lo, superordinate, baseDN, path='policyPath')
		position.setDn (position_dn)
		policy_object = policy_module.object(co, lo, position=position, superordinate=superordinate)
		count_lo()
		policy_object.open()
		for k, v in values.iteritems ():
			policy_object[k] = v
		try:
			create_object(policy_object)
		except:
			print "WARNING: Error creating policy %s" % policy_object.dn
			traceback.print_exc (100, sys.stdout)
			policy_object = None
			success = False
	elif overwrite_policy:
		policy_object.open ()
		for k, v in values.iteritems ():
			policy_object[k] = v
		try:
			policy_object.modify ()
		except:
			print "WARNING: Error modifying policy %s" % policy_object.dn
			traceback.print_exc (100, sys.stdout)
			policy_object = None

	if policy_object:
		# add policy reference to dhcp_subnet_object
		dn = policy_object.dn
		try:
			lob = lo.get (dhcp_subnet_object.dn, ['objectClass'])
			if 'univentionPolicyReference' not in lob.get ('objectClass', []):
				lo.modify (dhcp_subnet_object.dn, [ ('objectClass','','univentionPolicyReference') ])

			lob = lo.get (dhcp_subnet_object.dn, ['univentionPolicyReference'])
			if policy_object.dn not in lob.get ('univentionPolicyReference', []):
				print 'connecting dhcp subnet (%s) with policy (%s)' % (dhcp_subnet_object.dn, policy_object.dn)
				lo.modify (dhcp_subnet_object.dn, [ ('univentionPolicyReference','',policy_object.dn) ])
		except:
			print "WARNING: Error modifying policy %s" % policy_object.dn
			traceback.print_exc (100, sys.stdout)
			policy_object = None
			success = False

	return ( success, dn )

def set_netbiosserver_for_subnet (network, ip, schoolNr, overwrite_policy=False):
	"""
	@param	ip	ipaddr object for the netbios server
	@param	schoolNr	school number

	The Netbios node type is set to 8 H-node: Hybrid - WINS, then broadcast
	"""
	values = {
			'name':'%s-%s' % (schoolNr.lower (), network.network_ext),
			'netbios_node_type':'8',
			'netbios_name_servers':ip.ip_ext}
	dn = "cn=%s,cn=netbios,cn=dhcp,cn=policies,%s" % (values['name'], getDN (schoolNr))
	return set_policy_for_dhcp_subnet (network, schoolNr, policy_dhcp_netbios_module, dn, values['name'], values=values, overwrite_policy=overwrite_policy)

def set_nameserver_for_subnet (network, ip, schoolNr, overwrite_policy=False):
	"""
	@param	ip	ipaddr object for the netbios server
	@param	schoolNr	school number
	"""
	values = {
			'name':'%s-%s' % (schoolNr.lower (), network.network_ext),
			'domain_name':domainname,
			'domain_name_servers':ip.ip_ext}
	dn = "cn=%s,cn=dns,cn=dhcp,cn=policies,%s" % (values['name'], getDN (schoolNr))
	return set_policy_for_dhcp_subnet (network, schoolNr, policy_dhcp_dns_module, dn, values['name'], values=values, overwrite_policy=overwrite_policy)

def set_router_for_subnet (network, ip, schoolNr, overwrite_policy=False):
	"""
	@param	ip	ipaddr object for the router
	@param	schoolNr	school number
	"""
	values = {
			'name':'%s-%s' % (schoolNr.lower (), network.network_ext),
			'routers':ip.ip_ext}
	dn = "cn=%s,cn=routing,cn=dhcp,cn=policies,%s" % (values['name'], getDN (schoolNr))
	return set_policy_for_dhcp_subnet (network, schoolNr, policy_dhcp_routing_module, dn, values['name'], values=values, overwrite_policy=overwrite_policy)

def import_computer():
	# argument is infile
	if len(sys.argv)>1:
		infile = sys.argv[1]
	else:
		print "must have one Argument for infile"
		sys.exit()

	print "infile is  : "+infile
	inf = open(infile,'r')

	problem_hints=""
	linecnt=0

	line=inf.readline()
	while not line=="":
		linecnt += 1
		print 'Processing line %d: %s' % (linecnt, line),

		parsed=line.strip('\r\n').split(sepchar)

		ctype = parsed[0]
		name  = parsed[1].lower ()
		MAC      = parsed[2]
		schoolNr = parsed[3]
		IP       = parsed[4]
		inventoryNumbers = parsed[5].strip().split(',')

		verify_school_ou(schoolNr, co, lo, baseDN)

		ip = ipaddr.IPv4 (IP)

		# invoke pre hooks
		hooks.pre( 'computer', 'A', line = line )

		success = True
		dn = None
		if '/' not in IP:
			ip.prefixlen = default_prefixlen
			print 'WARNING: no netmask specified for ip address %s using %s' % (ip.ip_ext, ip.netmask_ext)

		module = univention.admin.modules.get("computers/%s"%ctype)
		if not module:
			print 'ERROR: Type "%s" not found for computer "%s".' % (ctype, name)
			print 'Ignoring of line %d' % linecnt
			success = False
		else:
			position_basedn = univention.admin.uldap.position(baseDN)
			univention.admin.modules.init (lo, position_basedn, module)

			if check_computer(module,name,schoolNr):
				print "computer %s already exists (school %s)"%(name,schoolNr)
			else:
				mac_used=check_macAddress(MAC)
				if mac_used:
					old_mac=MAC
					MAC=generate_new_mac(schoolNr, ip.ip_ext)
					print 'mac %s already used, set mac to %s (resolve manually)'%(old_mac,MAC)

				print "generate computer %s (school %s)"%(name,schoolNr)

				success = create_network(schoolNr, ip)

				position.setDn("cn=computers,%s" % (getDN (schoolNr), ))
				object=module.object(co, lo, position=position, superordinate=superordinate)
				count_lo()
				object.open()
				object['name'] = name
				object['mac']  = MAC
				object['inventoryNumber']=inventoryNumbers
				if not ip.ip == ip.network:
					object['ip'] = ip.ip_ext
					print "set ip to %s is not net %s" % (ip.ip_ext, ip.network_ext)
				object['network'] = 'cn=%s-%s,cn=networks,%s' % (schoolNr.lower (), ip.network_ext, getDN (schoolNr))
				try:
					create_object(object)
				except:
					print "WARNING: Error creating computer %s"%object.dn
					traceback.print_exc (100, sys.stdout)
					success = False

			print 'Processing of line %d completed' % linecnt

		# invoke post hooks
		if success:
			hooks.post( 'computer', 'A', dn = object.dn, line = line )

		# read next line
		line=inf.readline()

def import_router():
	"""
	No computer object is created on importing routers! But the dhcp-routing
	policy is set to the IP address of the router
	"""
	import_networks (router_only=True)

def import_group():
	# argument is infile
	if len(sys.argv)>1:
		infile = sys.argv[1]
	else:
		print "must have one Argument for infile"
		sys.exit()

	print "infile is  : "+infile
	inf = open(infile,'r')

	problem_hints=""

	line=inf.readline().strip('\r\n')
	while not line=="":

		parsed=line.strip('\r\n').split(sepchar)

		action = parsed[0]   # action=A(dd, M(odify, D(elete
		schoolNr = parsed[1]
		ClassID = parsed[2]
		Descrpt = parsed[3]

		group_dn="cn=%s,cn=klassen,cn=%s,cn=groups,%s"%(ClassID, cn_pupils, getDN (schoolNr))
		share_dn="cn=%s,cn=klassen,cn=shares,%s"%(ClassID, getDN (schoolNr))

		verify_school_ou(schoolNr, co, lo, baseDN)

		# invoke pre hooks
		hooks.pre( 'group', action, line = line )
		success = True
		dn = None

		if action in ['A','M']:	# Add/Modify group
## 			verify_group(group_dn, co, lo, superordinate, baseDN)
## 			object = univention.admin.objects.get(group_module, co, lo, position='', dn=group_dn, arg='')
## 			object.open()
## 			object['description']=Descrpt
## 			object.modify()
## 			verify_group_share(schoolNr, ClassID, co, lo, superordinate, baseDN)


## 		elif action == 'M':	# M)odify group
			verify_group(group_dn, co, lo, superordinate, baseDN)
			object = univention.admin.objects.get(group_module, co, lo, position='', dn=group_dn, arg='')
			count_lo()
			object.open()
			oldDescrpt = object['description']
			object['description']=Descrpt
			print "Changed Description of %s from %s to %s"%(group_dn, oldDescrpt, Descrpt)
			object.modify()
			verify_group_share(schoolNr, ClassID, co, lo, superordinate, baseDN)
			dn = object.dn
		elif action == 'D':	# D)elete group
			try:
				delete_dn(group_dn, group_module, co, lo)
				delete_dn(share_dn, group_module, co, lo)
				dn = group_dn
			except:
				success = False

		if success:
			hooks.post( 'group', action, dn = dn, line = line )

		line=inf.readline().strip('\r\n')

def import_printer():
	# argument is infile
	if len(sys.argv)>1:
		infile = sys.argv[1]
	else:
		print "must have one Argument for infile"
		sys.exit()

	print "infile is  : "+infile
	inf = open(infile,'r')

	line=inf.readline().strip('\r\n')
	while not line=="":

		parsed=line.strip('\r\n').split(sepchar)

		# completely new
		action = parsed[0]   # action=A(dd, M(odify, D(elete
		schoolNr = parsed[1]
		spoolHost = parsed[2].lower ()
		if '.' not in spoolHost:
			spoolHost = '%s.%s' % (spoolHost, configRegistry['domainname'])
		printerName = parsed[3]
		printerUri = parsed[4]
		def parseString (parsed, idx, default=None):
			res = default
			if len (parsed) > idx:
				string = parsed[idx]
				if string:
					res = string
			return res
		printerModel = parseString (parsed, 5)

		position_dn ="cn=%s,cn=printers,%s" % (printerName, getDN (schoolNr))
		container ="cn=printers,%s" % (getDN (schoolNr), )

		# invoke pre hooks
		hooks.pre( 'printer', action, line = line )
		dn = None
		success = True

		objects=''
		try:
			objects = univention.admin.modules.lookup(printer_module, co, lo, scope='sub', superordinate=superordinate, base=container,
													  filter=univention.admin.filter.expression(type,name))
			count_lo()
		except:
			pass
		if objects:
			for object in objects:
				if codecs.latin_1_encode(univention.admin.objects.dn(object))[0]==position_dn:
					container_exists = 1

		if action in ['A','M']: # Add/Modify printer
			position=univention.admin.uldap.position(baseDN)
			position.setDn(container)
			if action == 'A':
				object = printer_module.object(co, lo, position, superordinate=superordinate)
			else:
				object = univention.admin.objects.get(printer_module, co, lo, position='', dn=position_dn, arg='')
			count_lo()
			object.open()
			object['name'] = printerName
			object['spoolHost'] = [spoolHost]
			object['setQuota'] = '0' # WORKAROUND for Bug #14858
			object['uri'] = printerUri
			if printerModel:
				object['model'] = printerModel
			else:
				object['model'] = 'None'
			if action == 'A':
				try:
					create_object(object)
				except:
					success = False
				dn = object.dn
			else:
				try:
					print 'modifying object %s' % position_dn
					object.modify()
				except:
					traceback.print_exc (100, sys.stdout)
					success = False
				dn = object.dn

		elif action == 'D':	# D)elete printer
			dn = position_dn
			try:
				delete_dn(position_dn, printer_module, co, lo)
			except:
				success = False

		# invoke post hooks
		if success:
			hooks.post( 'printer', action, dn = dn, line = line )

		line=inf.readline().strip('\r\n')

def activate_groupmembers():
	#  syntax: $0 <groupXXX> [0|1] [0|1]"
	# <groupXXX>    group
	# [0|1]         optional: deactivate | activate
	# [0|1]         optional: keep passwords | set random passwords

	chgrp = 1
	chpasswd = 0
	status = None

	if len(sys.argv) < 2:
		print 'must have at least one argument'
		print 'activate_groupmembers <groupXXX> <newStatus> <changePassword>'
		print ''
		print '<groupXXX>        group that shall be dis-/enabled'
		print '<newstatus>       0=disabled, 1=enabled'
		print '<changePassword>  0=keep passwords, 1=set random passwords'
		print '                  the logfile groupXXX.csv contains all activated users'
		sys.exit()
	if len(sys.argv) > 1:
		actgrp = sys.argv[1]
	if len(sys.argv) > 2:
		status = int(sys.argv[2])
	if len(sys.argv) > 3:
		chpasswd = int(sys.argv[3])

	if status not in [0,1]:
		print 'invalid value for <newstatus>!'
		sys.exit()
	elif chpasswd not in [0,1]:
		print 'invalid value for <changePassword>!'
		sys.exit()

	# inverted logic
	disabled=str( 1 - status )

	###

	# outfile = os.path.basename(actgrp+'.csv')
	outfile = "/var/lib/ucs-school-import/activate-grp-%s-%s.csv" % (time.strftime("%Y%m%d-%H%M%S"), actgrp)
	print "outfile is : "+outfile
	if os.path.exists(outfile):
		print 'outfile %s does already exist. Stopping here.' % outfile
		sys.exit()
	outf = open(outfile,'w')


	# get group
	objects = univention.admin.modules.lookup(group_module, co, lo, scope='sub', superordinate=superordinate, base=baseDN,
											  filter=univention.admin.filter.expression('cn',actgrp))
	out_line = ('%%s%(sep)s' * 7 + '\n') % {'sep':sepchar}
	for grp in objects:

		# get group members
		if "uniqueMember" in grp.oldattr:
			grpmembers = grp.oldattr["uniqueMember"]
			for memberdn in grpmembers:

				membergrplist = ""
				grpobjlist = univention.admin.modules.lookup(group_module, co, lo, scope='sub', superordinate=superordinate, base=baseDN,
														  filter=univention.admin.filter.expression('uniqueMember', memberdn))
				for grpobj in grpobjlist:
					if grpobj.dn != grp.dn:
						if len(membergrplist):
							membergrplist += "," + grpobj.oldattr["cn"][0]
						else:
							membergrplist += grpobj.oldattr["cn"][0]

				# modify each member
				memberobj = univention.admin.objects.get(user_module, co, lo, position='', dn=memberdn, arg='')
				count_lo()
				memberobj.open()

				memberobj['disabled'] = str(disabled)
				memberobj.modify()

				print memberdn,
				if status == 0:
					print 'deactivated',
				else:
					print 'activated',

				passwd = '*'
				if chpasswd:
					passwd = create_passwd()
					memberobj['password'] = passwd
					memberobj['overridePWHistory'] = '1'
					memberobj['overridePWLength'] = '1'
					memberobj.modify()
					print 'and set random password',

				# write csv line
				snr = memberdn[ memberdn.find('ou=') + 3 : ]
				snr = snr[ : snr.find(',') ]
				outf.write(out_line % (snr, actgrp, memberobj['firstname'], memberobj['lastname'], passwd, memberobj['mailPrimaryAddress'], membergrplist))

				print

	outf.close()

def export_computer():
	#  syntax: $0 <ou> <filename>"
	# <ou>        computers of OU <ou> shall be exported
	# <filename>  output filename

	if len(sys.argv) != 3:
		print 'must have at least two arguments'
		print 'export_computer <ou> <output-filename>'
		print ''
		sys.exit()
	ou = sys.argv[1]
	outfile = sys.argv[2]

	# outfile = os.path.basename(actgrp+'.csv')
	print "outfile is : "+outfile
	if os.path.exists(outfile):
		print 'outfile %s does already exist. Stopping here.' % outfile
		sys.exit()
	outf = open(outfile,'w')

	ouBaseDN = getDN (ou)

	# get group
	print 'looking for objects... please wait...'
	objects = univention.admin.modules.lookup(computer_module, co, lo, scope='sub', superordinate=superordinate, base=ouBaseDN, filter=None)
	print 'writing data of %d objects...' % len(objects)
	out_line = ('%%s%(sep)s' * 5 + '\n') % {'sep':sepchar}
	for host in objects:
		host.open()
		inventoryNumber = ''
		ip = ''
		mac = ''
		if host.has_key('inventoryNumber') and host['inventoryNumber']:
			inventoryNumber = host['inventoryNumber'][0]
		if host.has_key('ip') and host['ip']:
			ip = host['ip'][0]
		if host.has_key('mac') and host['mac']:
			mac = host['mac'][0]
#		Name,OU,1.Zeile Inventar-Nr.,IP-Adresse
		outf.write(out_line % (host['name'], ou, inventoryNumber, ip, mac))
	outf.close()

#------------------------------------------------------------------------------------------#

# init univention-directory-manager
tls=2

secretFile=open('/etc/ldap.secret','r')
pwdLine=secretFile.readline()
pwd=re.sub('\n','',pwdLine)

locounts=0
lo = None
try:
	lo=univention.admin.uldap.access(host=configRegistry['ldap/master'], base=baseDN, binddn='cn=admin,'+baseDN, bindpw=pwd, start_tls=tls)
except Exception, e:
	univention.debug.debug(univention.debug.ADMIN, univention.debug.WARN, 'authentication error: %s' % str(e))
	print 'ERROR: authentication error: %s' % str(e)
	sys.exit(1)

co            = univention.admin.config.config()
position      = univention.admin.uldap.position(baseDN)
superordinate = None


user_module                = univention.admin.modules.get("users/user")
group_module               = univention.admin.modules.get("groups/group")
cn_module                  = univention.admin.modules.get("container/cn")
ou_module                  = univention.admin.modules.get("container/ou")
dcmaster_module              = univention.admin.modules.get("computers/domaincontroller_master")
dcbackup_module              = univention.admin.modules.get("computers/domaincontroller_backup")
server_module              = univention.admin.modules.get("computers/domaincontroller_slave")
share_module               = univention.admin.modules.get("shares/share")
printer_module             = univention.admin.modules.get("shares/printer")
computer_module            = univention.admin.modules.get("computers/computer")

dhcp_server_module         = univention.admin.modules.get("dhcp/server")
dhcp_service_module        = univention.admin.modules.get("dhcp/service")
dhcp_subnet_module         = univention.admin.modules.get("dhcp/subnet")

dns_reverse_zone_module    = univention.admin.modules.get("dns/reverse_zone")

network_module             = univention.admin.modules.get("networks/network")

policy_dhcp_routing_module = univention.admin.modules.get("policies/dhcp_routing")
policy_dhcp_netbios_module = univention.admin.modules.get("policies/dhcp_netbios")
policy_dhcp_dns_module     = univention.admin.modules.get("policies/dhcp_dns")

setting_module             = univention.admin.modules.get("settings/default")

for m in (
		user_module,
		group_module,
		cn_module,
		ou_module,
		server_module,
		share_module,
		printer_module,
		computer_module,
		dhcp_server_module,
		dhcp_service_module,
		dhcp_subnet_module,
		dns_reverse_zone_module,
		network_module,
		policy_dhcp_routing_module,
		policy_dhcp_netbios_module,
		policy_dhcp_dns_module,
		setting_module,
		):
	univention.admin.modules.init (lo, position, m)

# get default group
default_group = "cn=Domain Users,cn=groups,%s"%baseDN # fallback
for object in univention.admin.modules.lookup(setting_module, co, lo, scope='sub', superordinate=superordinate, base='', filter=''):
	if object.has_key("defaultGroup"):
		default_group=object["defaultGroup"]
	else: print "WARNING, no default group found"
count_lo()

# select action
if sys.argv[0].endswith("import_user") or sys.argv[0].endswith("ucs-school-import"):
	import_user()
elif sys.argv[0].endswith("import_networks"):
	import_networks()
elif sys.argv[0].endswith("import_computer"):
	import_computer()
elif sys.argv[0].endswith("import_router"):
	import_router()
elif sys.argv[0].endswith("import_inventory_number"):
	set_inventory_number_for_computer()
elif sys.argv[0].endswith("import_group"):
	import_group()
elif sys.argv[0].endswith("import_printer"):
	import_printer()
elif sys.argv[0].endswith("create_ou"):
	dcName=None
	if len(sys.argv)>1 and sys.argv[1][0] != '-':
		ouname = sys.argv[1]
		if len(sys.argv)>2:
			dcName = sys.argv[2]

		# hostname based upon RFC 952: <let>[*[<let-or-digit-or-hyphen>]<let-or-digit>]
		if not re.match('^[a-zA-Z0-9](([a-zA-Z0-9-_]*)([a-zA-Z0-9]$))?$', ouname):
			print 'ERROR: invalid ou name given'
			sys.exit(1)

		# hostname based upon RFC 952: <let>[*[<let-or-digit-or-hyphen>]<let-or-digit>]
		if dcName and not re.match('^[a-zA-Z](([a-zA-Z0-9-_]*)([a-zA-Z0-9]$))?$', dcName):
			print 'ERROR: invalid domaincontroller name given'
			sys.exit(1)

		verify_school_ou(ouname, co, lo, baseDN, dcName=dcName)
		sys.exit(0)

	print 'syntax: create_ou <ou_name> [<dc_name>]'
	print '	  ou_name	 name of ou that shall be created or verified'
	print '	  dc_name	 name of domaincontroller for specified OU'
	print 'At least ou_name has to be passed to create_ou as argument.'
	print 'If dc_name is not specified the default domaincontroller name'
	print 'will be used. Defaultname: dc<ou_name>-01'
	sys.exit(1)

elif sys.argv[0].endswith("activate_groupmembers"):
	activate_groupmembers()
elif sys.argv[0].endswith("export_computer"):
	export_computer()
else:
	print "unknown action defined by the filename"
