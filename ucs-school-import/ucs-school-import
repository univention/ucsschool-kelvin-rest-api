#!/usr/bin/python2.4 -OO
# -*- coding: utf-8 -*-

#-> doesn't do:
# check usernames for correct values (no spaces)
# change the user's position in the tree (change the school i.e.)
# select Schools that are separated by kommata
# modify users school or type (pupil/teacher)

#-> needs definition:
# import access rights

# init list of created users and passwords
created_users = {}
# string of problems during process
problem_hints = ""
# separator char in infile
sepchar=';'

# wipe the following trailing and leading characters from group names
wipe_char_group='-'

# count access to ldap to reconnect after 1000 changes
locounts=0

import sys, string, re, codecs, os, copy, random, time, traceback

import ipaddr

import univention.debug
univention.debug.init('/var/log/univention/admin-cmd.log', 1, 0)

import univention.admin.uldap
import univention.admin.modules
import univention.admin.objects
import univention.config_registry

configRegistry=univention.config_registry.ConfigRegistry()
configRegistry.load()

baseDN=configRegistry['ldap/base']
domainname=configRegistry['domainname']

# FIXME: Are e-mail addresses provided?? otherwise it might be useful to
# configure this via UCR
#externaldomainname='schule.berlin.de'

district_enabled = False
if configRegistry['ucsschool/ldap/district/enable'].lower () in ('1', 'yes', 'true'):
	district_enabled = True

school_dcs = configRegistry['ucsschool/ldap/default/dcs']
# create edukativ DC by default
if school_dcs.strip () == '':
	school_dcs = 'edukativ'

verified_ous          = []
verified_groups       = []
verified_group_shares = []

cn_pupils   = configRegistry.get ('ucsschool/ldap/default/container/pupils', 'pupils')
cn_teachers = configRegistry.get ('ucsschool/ldap/default/container/teachers', 'teachers')
cn_admins   = configRegistry.get ('ucsschool/ldap/default/container/admins', 'admins')
cn_staff    = configRegistry.get ('ucsschool/ldap/default/container/staff', 'staff')

grp_prefix_pupils   = configRegistry.get ('ucsschool/ldap/default/groupprefix/pupils', 'pupils')
grp_prefix_teachers = configRegistry.get ('ucsschool/ldap/default/groupprefix/teachers', 'teachers')
grp_prefix_admins   = configRegistry.get ('ucsschool/ldap/default/groupprefix/admins', 'admins')
grp_prefix_staff    = configRegistry.get ('ucsschool/ldap/default/groupprefix/staff', 'staff')

role_pupil   = 'pupil'
role_teacher = 'teacher'
role_staff   = 'staff'

# TODO: make this configurable via UCR
generate_logins = False

if not (cn_pupils and cn_teachers and cn_admins and cn_staff):
	print 'ERROR: Unable to progress, one of these UCR variables is not set correctly:\n\tucsschool/ldap/default/container/pupils\n\tucsschool/ldap/default/container/teachers\n\tucsschool/ldap/default/container/staff\n\tucsschool/ldap/default/container/admins'
	sys.exit (1)

class ucsschool_person_modify:
	def __init__(self,line):

		# parse line here

		# there are 10 strings each line
		parsed =[]
		b_pos = 0
		e_pos = 0
		for i in range(21):
			e_pos = string.find(line,";",b_pos)
			parsed.append(codecs.utf_8_decode(line[b_pos:e_pos])[0])
			b_pos=e_pos+1
		parsed=line.split(sepchar)

		#self.modtype   = parsed[0] # A,M or D: add, modify or delete
		#if not generate_logins:
		#	self.login = parsed[1]
		#self.sname     = (utf8_to_ascii(unicode(parsed[2]))).replace(' ', '') # surename
		#self.name      = (utf8_to_ascii(unicode(parsed[3]))).replace(' ', '') # first name
		#self.sNr       = parsed[10] # schoolNr(s)
		#self.cNr       = parsed[17] + parsed[18] # classNr
		#self.rights    = parsed[6] # users which may change this entry # NOT USED
		#self.mail      = self.login+"@"+externaldomainname
		#self.isTeacher = parsed[21][0]
		#self.isActive  = parsed[11][0]
		#self.isStaff   = parsed[22][0]
		#self.problem_hints = ""

		# FIXME: this should be the default for the import format
		self.modtype   = parsed[0] # A,M or D: add, modify or delete
		self.login     = parsed[1].lower ()
		self.sname     = parsed[2] # surename
		self.name      = parsed[3] # first name
		self.sNr       = parsed[4] # schoolNr(s)
		self.cNr       = parsed[5] # classNr
		self.rights    = parsed[6] # users which may change this entry
		self.mail      = parsed[7]
		# order changed
		self.isActive  = parsed[8][0] # was: 9
		self.isTeacher = parsed[9][0] # was: 8
		self.isStaff   = parsed[10][0]
		self.problem_hints = ""

		if generate_logins:
			if self.isTeacher == "1" or self.isStaff == "1":
				self.login = ('%s.%s' % (self.name[0], self.sname[:8])).lower()
				print "DEBUG: Teacher found: creating login name " + self.login
			else:
				self.login = self.name[:6].lower()
				print "DEBUG: Student found: creating login name " + self.login

		if ',' in self.sNr:
			self.allsNrs= self.sNr.split(',')
			self.sNr=self.allsNrs[0]
			self.other_sNr=self.allsNrs[1:]
		else:
			self.allsNrs=[self.sNr]
			self.other_sNr=[]

		# split into multiple class number if comma is present
		if ',' in self.cNr:
			self.cNr = self.cNr.split(',')
		else:
			self.cNr = [ self.cNr ]
		# wipe invalid character from class numbers
		for i in range(len(self.cNr)):
			self.cNr[i] = self.wipeInvalidCharGroup( self.cNr[i] )
		# remove empty strings
		self.cNr = [ x for x in self.cNr if x ]
		# sort classes
		self.cNr.sort()

	def wipeInvalidCharGroup(self, groupName):
		global wipe_char_group

		ok = False
		while groupName and not ok:
			if groupName[0] in wipe_char_group:
				groupName = groupName[1:]
			else:
				ok = True
		ok = False
		while groupName and not ok:
			if groupName[-1] in wipe_char_group:
				groupName = groupName[0:-1]
			else:
				ok = True
		return groupName

	def getOtherPersons(self):
		persons=[]

		for schoolNr in self.other_sNr:
			person = copy.deepcopy(self)
			person.login = ("%s_%s"%(self.login,schoolNr)).lower ()
			person.sNr=schoolNr
			person.other_sNr=[] # has no "slave"-accounts
			self.mail="" # no extra mail address
			person.cNr=[] # no class in other ou
			person.isTeacher = '0'
			person.isStaff = '0'
			if self.getRole () == role_teacher:
				person.isTeacher = '1'
			elif self.getRole () == role_staff:
				person.isTeacher = '1'

			persons.append(person)

		return persons

	def getPosition_dn(self):
		cn = {role_teacher:cn_teachers,
				role_pupil:cn_pupils,
				role_staff:cn_staff}[self.getRole ()]
		return "cn=%s,cn=users,%s" % (cn, getDN (self.sNr))

	def getDN(self):
		return "uid="+self.login+","+self.getPosition_dn()

	def default_groups(self):
		default_groups=[]

		# default group
		default_groups.append("cn=Domain Users "+self.sNr+",cn=groups,%s" % (getDN (self.sNr), ))

		user_grp_prefix = {role_teacher:grp_prefix_teachers,
				role_pupil:grp_prefix_pupils,
				role_staff:grp_prefix_staff}[self.getRole ()]
		# class if available
		for cnr in self.cNr:
			default_groups.append("cn=" + cnr + ",cn=klassen,cn=%s,cn=groups,%s" % (cn_pupils, getDN (self.sNr)))

		default_groups.append("cn=%s%s,cn=groups,%s"%(user_grp_prefix, self.sNr, getDN (self.sNr)))

		return default_groups

	def getRole(self):
		"""returns the user's role"""
		role = role_pupil
		if self.isTeacher == '1':
			role = role_teacher
		elif self.isStaff == '1':
			role = role_staff
		return role

def count_lo():
	pass # was a workaround for slapd locking-failures, not necessary any more
	global locounts
	global lo
	locounts=locounts+1
	#print 'locounts %s'%locounts,
	if locounts>1000:
		try:
			print 'ldap-lookup count exceeded, reconnect'
			lo=univention.admin.uldap.access(host=configRegistry['ldap/master'], base=baseDN, binddn='cn=admin,'+baseDN, bindpw=pwd, start_tls=tls)
			locounts=0
		except Exception, e:
			univention.debug.debug(univention.debug.ADMIN, univention.debug.WARN, 'authentication error: %s' % str(e))
			print 'ERROR: authentication error: %s' % str(e)
			sys.exit(1)

xlate={0xc0:'A', 0xc1:'A', 0xc2:'A', 0xc3:'A', 0xc4:'A', 0xc5:'A',
		0xc6:'Ae', 0xc7:'C',
		0xc8:'E', 0xc9:'E', 0xca:'E', 0xcb:'E',
		0xcc:'I', 0xcd:'I', 0xce:'I', 0xcf:'I',
		0xd0:'Th', 0xd1:'N',
		0xd2:'O', 0xd3:'O', 0xd4:'O', 0xd5:'O', 0xd6:'O', 0xd8:'O',
		0xd9:'U', 0xda:'U', 0xdb:'U', 0xdc:'U',
		0xdd:'Y', 0xde:'th', 0xdf:'ss',
		0xe0:'a', 0xe1:'a', 0xe2:'a', 0xe3:'a', 0xe4:'a', 0xe5:'a',
		0xe6:'ae', 0xe7:'c',
		0xe8:'e', 0xe9:'e', 0xea:'e', 0xeb:'e',
		0xec:'i', 0xed:'i', 0xee:'i', 0xef:'i',
		0xf0:'th', 0xf1:'n',
		0xf2:'o', 0xf3:'o', 0xf4:'o', 0xf5:'o', 0xf6:'o', 0xf8:'o',
		0xf9:'u', 0xfa:'u', 0xfb:'u', 0xfc:'u',
		0xfd:'y', 0xfe:'th', 0xff:'y',
		0xae:'R', 0xaf:'_', 0xb8:'c',
		0xba:'o', 0x17e : 'z',
		0x100: 'A', 0x101 : 'a', 0x102 : 'A'
		}

nonasciire = re.compile(u'([\x00-\x7f]+)|([^\x00-\x7f])', re.UNICODE).sub

def utf8_to_ascii (unicrap):
	return str(nonasciire(lambda x: x.group(1) or xlate.setdefault(ord(x.group(2)), ''), unicrap))

def extract_district (schoolNr):
	try:
		return schoolNr[:2]
	except IndexError:
		# TODO: add more debug output
		print "ERROR: Unable to extract district from school number: %s' % schoolNr + \
				'\n\tIf you don't use the district model deactivate UCR variable ucsschool/ldap/district/enable"

def getDN (schoolNr, base='school', basedn=baseDN):
	"""
	@param	base Values are either school, district or base
	@return	According to the base a specific part of dn is returned.
			Let's suppose the following school dn:
			ou=SCHOOL,ou=DISTRICT,dc=BASE,dc=DN

			The following is returned
			'base'		-> dc=BASE,dc=DN
			'district'	-> ou=DISTRICT,dc=BASE,dc=DN
			'school'	-> ou=SCHOOL,ou=DISTRICT,dc=BASE,dc=DN
	"""
	dn = '%(school)s%(district)s%(basedn)s'
	values = {'school':'ou=%s,'%schoolNr, 'district':'', 'basedn':basedn}
	if district_enabled:
		district = extract_district (schoolNr)
		if not district:
			print "ERROR: Unable to continue execution without district number. School number: %s" % schoolNr
			sys.exit(1)
		values['district'] = 'ou=%s,' % district
	if base == 'district':
		values['school'] = ''
	elif base == 'base':
		values['district'] = ''
		values['school'] = ''
	return dn % values

def verify_school_ou(schoolNr, co, lo, baseDN):
	global problem_hints

	if schoolNr in verified_ous:
		print "verify ou for school nr %s already done"%schoolNr
		return True

	# create ucsschool container if it does not exists
	verify_container ('cn=ucsschool,cn=groups,%s' % baseDN, cn_module, co, lo, superordinate, baseDN, 'groupPath')

	if district_enabled:
		verify_container (getDN (schoolNr, base='district'), ou_module, co, lo, superordinate, baseDN)

	print "verify ou for school nr %s"%schoolNr
	# list of needed sub-containers, the dictionary-key adds the container as default during create in verify_container
	container={'0printerPath':['cn=printers'],
			   '1userPath':['cn=users','cn=%s,cn=users' % cn_pupils,'cn=%s,cn=users' % cn_teachers,'cn=%s,cn=users' % cn_staff,'cn=%s,cn=users' % cn_admins],
			   '2computerPath':['cn=computers','cn=server,cn=computers'],
			   '3networkPath':['cn=networks'],
			   '4groupPath':['cn=groups','cn=%s,cn=groups' % cn_pupils,'cn=%s,cn=groups' % cn_teachers,'cn=%s,cn=groups' % cn_staff,'cn=klassen,cn=%s,cn=groups' % cn_pupils,'cn=raeume,cn=groups'],
			   '5dhcpPath':['cn=dhcp'],
			   '6policyPath':['cn=policies'],
			   '7sharePath':['cn=shares','cn=klassen,cn=shares'],
			   '8none':['cn=dc,cn=server,cn=computers']
			   }
	# FIXME: die Policies sollten besser mit der Gruppe verknüpft werden, um
	# z.B. Mitarbeiter und Lehrer im selben Container pflegen zu können
	#container_policies = { 'cn=%s,cn=users' % cn_teachers: ['cn=default-lehrer,cn=console,cn=policies,' + baseDN] }
	container_policies = { }

	ou_base = getDN (schoolNr)
	verify_container(ou_base, ou_module, co, lo, superordinate, baseDN, path='')
	keys=container.keys()
	keys.sort()
	for path in keys:
		for dn in container[path]:
			if path[1:]=='none': path=' '
			verify_container('%s,%s'%(dn,ou_base),cn_module, co, lo, superordinate, baseDN, path=path[1:])

	# create groups if not exsistant
	groups=["cn=admins%s,cn=ouadmins,cn=groups,%s" % (schoolNr.lower (), baseDN),
			"cn=%s%s,cn=groups,%s" % (cn_pupils, schoolNr.lower (), getDN (schoolNr)),
			"cn=%s%s,cn=groups,%s" % (cn_teachers, schoolNr.lower (), getDN (schoolNr)),
			"cn=%s%s,cn=groups,%s" % (cn_staff, schoolNr.lower (), getDN (schoolNr))]
	for group in groups:
		verify_group(group, co, lo, superordinate, baseDN)

	groups=[
			"cn=DC-Verwaltungsnetz,cn=ucsschool,cn=groups,%s" % (baseDN, ),
			"cn=Member-Verwaltungsnetz,cn=ucsschool,cn=groups,%s" % (baseDN, ),
			"cn=DC-Edukativnetz,cn=ucsschool,cn=groups,%s" % (baseDN, ),
			"cn=Member-Edukativnetz,cn=ucsschool,cn=groups,%s" % (baseDN, ),

			"cn=OU%s-DC-Verwaltungsnetz,cn=ucsschool,cn=groups,%s" % (schoolNr.lower (), baseDN),
			"cn=OU%s-Member-Verwaltungsnetz,cn=ucsschool,cn=groups,%s" % (schoolNr.lower (), baseDN),
			"cn=OU%s-DC-Edukativnetz,cn=ucsschool,cn=groups,%s" % (schoolNr.lower (), baseDN),
			"cn=OU%s-Member-Edukativnetz,cn=ucsschool,cn=groups,%s" % (schoolNr.lower (), baseDN),
			]
	for group in groups:
		verify_group(group, co, lo, superordinate, baseDN)


	for dc in school_dcs.split ():
		dccn = 'dc%s-01' % schoolNr.lower ()
		dcgroups = ["cn=OU%s-DC-Edukativnetz,cn=ucsschool,cn=groups,%s" % (schoolNr.lower (), baseDN),
				"cn=DC-Edukativnetz,cn=ucsschool,cn=groups,%s" % (baseDN, )]
		if dc == 'verwaltung':
			dccn = 'dc%sv-01' % schoolNr.lower () # this is the name convention, a trailing v for Verwaltungsnetz DCs
			dcgroups = ["cn=OU%s-DC-Verwaltungsnetz,cn=ucsschool,cn=groups,%s" % (schoolNr.lower (), baseDN),
					"cn=DC-Verwaltungsnetz,cn=ucsschool,cn=groups,%s" % (baseDN, )]

		# create server if not exsistant
		objects = univention.admin.modules.lookup(server_module, co, lo, scope='sub', superordinate=superordinate, base=baseDN,
												  filter=univention.admin.filter.expression('cn', dccn))
		count_lo()

		# create server if not existent
		server_exists=0
		correct_server_exists=0
		if objects:
			server_exists = 1 # can't create another server with this id
			correct_server = "cn=%s,cn=dc,cn=server,cn=computers,%s"%(dccn, getDN (schoolNr))
			for object in objects:
				if object.dn == correct_server:
					correct_server_exists=1
		if server_exists and not correct_server_exists:
			print "There is already a server entry in the wrong container"
		if not server_exists:
			position.setDn("cn=dc,cn=server,cn=computers,"+getDN (schoolNr))
			object=server_module.object(co, lo, position=position, superordinate=superordinate)
			count_lo()
			object.open()
			object["name"]=dccn
			object["unixhome"]="/dev/null"
			object["shell"]="/bin/bash"
			object["primaryGroup"]="cn=DC Slave Hosts,cn=groups,%s"%baseDN
			for dcgroup in dcgroups:
				if dcgroup not in object["groups"]:
					object["groups"].append (dcgroup)
			create_object(object)
			print "need to create server: %s"%object.dn

		# create dhcp-service if not exsistant
		objects = univention.admin.modules.lookup(dhcp_service_module, co, lo, scope='sub', superordinate=superordinate, base=baseDN,
												  filter=univention.admin.filter.expression('cn', schoolNr.lower ()))
		count_lo()
		service_exists=0
		if objects:
			service = "cn=%s,cn=dhcp,%s"%(schoolNr.lower (), getDN (schoolNr))
			for object in objects:
				if object.dn == service:
					service_exists=1
					dhcp_service_object=object
		if not service_exists:
			position.setDn("cn=dhcp,%s" % (getDN (schoolNr), ))
			object=dhcp_service_module.object(co, lo, position=position, superordinate=superordinate)
			count_lo()
			object.open()
			object["service"]=schoolNr.lower ()
			create_object(object)
			dhcp_service_object=object
			print "need to create dhcp service: %s"%object.dn

		# create dhcp-server if not exsistant
		objects = univention.admin.modules.lookup(dhcp_server_module, co, lo, scope='sub', superordinate=dhcp_service_object, base=baseDN,
												  filter=univention.admin.filter.expression('cn',dccn))
		count_lo()
		server_exists=0
		if objects:
			server = "cn=%s,cn=%s,cn=dhcp,%s"%(dccn,schoolNr.lower (), getDN (schoolNr))
			for object in objects:
				if object.dn == server:
					server_exists=1
		if not server_exists:
			position.setDn("cn=%s,cn=dhcp,%s"%(schoolNr.lower (), getDN (schoolNr)))
			object=dhcp_server_module.object(co, lo, position=position, superordinate=dhcp_service_object)
			count_lo()
			object.open()
			object["server"]=dccn
			create_object(object)
			print "need to create dhcp server: %s"%object.dn

		# create userlogon-share if not exsistant
		objects = univention.admin.modules.lookup(share_module, co, lo, \
				scope='sub', superordinate=dhcp_service_object, \
				base='cn=shares,%s' % ( getDN (schoolNr)), \
				filter=univention.admin.filter.expression('cn','userlogon'))
		count_lo()
		share_exists=0
		if objects:
			share = "cn=userlogon,cn=shares,%s" % (getDN (schoolNr), )
			for object in objects:
				if object.dn == share:
					share_exists=1
		if not share_exists:
			position.setDn("cn=shares,%s" % (getDN (schoolNr), ))
			object=share_module.object(co, lo, position=position)
			count_lo()
			object.open()
			object.options=['samba']
			object["name"]="userlogon"
			object["host"]=dccn
			object['path']='/var/lib/samba/userlogon'
			create_object(object)
			print "need to create share: %s"%object.dn

	if not schoolNr in verified_ous:
		verified_ous.append(schoolNr)

	# attach policies if needed
	for containerdn in container_policies.keys():
		# verify for each container that container does exist
		verify_container('%s,%s' % (containerdn,ou_base), cn_module, co, lo, superordinate, baseDN, '')
		pollist = container_policies[containerdn]

		# test if all policy objects exist and if all referenced objects are policy objects
		for poldn in pollist:
			oc = lo.get( poldn, ['objectClass'] )
			if not oc:
				print "Object to be referenced does not exist: " + poldn
				problem_hints = problem_hints + "there were problems verifying this ou %s\n" % schoolNr
				break
			elif not 'univentionPolicy' in oc['objectClass']:
				print "Object to be referenced is no valid policy: " + poldn
				problem_hints = problem_hints + "there were problems verifying this ou %s\n" % schoolNr
				break
		else:
			# add univentionPolicyReference if neccessary
			oc = lo.get( '%s,%s' % (containerdn,ou_base), ['objectClass'] )
			if not 'univentionPolicyReference' in oc.get('objectClass',[]):
				lo.modify('%s,%s' % (containerdn,ou_base), [ ('objectClass','','univentionPolicyReference') ] )
			# add all missing policies
			pl = lo.get( '%s,%s' % (containerdn,ou_base), ['univentionPolicyReference'] )
			modlist=[]
			for poldn in pollist:
				if not poldn in pl.get('univentionPolicyReference',[]):
					modlist.append(('univentionPolicyReference','',poldn))
					print 'need to attach policy: %s' % poldn
			lo.modify('%s,%s' % (containerdn,ou_base),modlist)

def create_sub_object(o):
	# create a user object without mailPrimaryAddress but with
	# univentionAbordnung objectclass and univentionAbordnungMasterDn
	# with dn of the user who has the same mailPrimaryAddress

	# univentionAbordnungMasterDn
	mail = o['mailPrimaryAddress']
	o['mailPrimaryAddress'] = []
	ml = []

	# create sub account without mailPrimaryAddress
	dn = o.create()

	# search mailPrimaryAddress
	result = o.lo.search(filter='(&(objectClass=univentionMail)(objectClass=posixAccount)(mailPrimaryAddress=%s))' % mail, attr=['mailPrimaryAddress'])
	superdn, attrs = result[0]

	# append objectclass and attribut to sub account
	ml.append(('objectClass', None, "univentionAbordnung"))
	ml.append(("univentionAbordnungMasterDn", None, superdn))
	try:
		o.lo.modify(dn, ml)
	except:
		problem_hints = "problems while setting univentionAbordnung to " + dn + "\n"


def create_object(o, ignore_exists=0):
	exists=0
	try:
		dn=o.create()
		print 'creating object', dn
	except univention.admin.uexceptions.objectExists:
		if not ignore_exists:
			print 'ERROR: Object exists-1 (objectExists)'
			traceback.print_exc (100, sys.stdout)
		else:
			exists=1
	except univention.admin.uexceptions.uidAlreadyUsed:
		if not ignore_exists:
			print 'ERROR: Object exists-2 (uidAlreadyUsed)'
			traceback.print_exc (100, sys.stdout)
		else:
			exists=1
	except univention.admin.uexceptions.dhcpServerAlreadyUsed:
		if not ignore_exists:
			print 'ERROR: Object exists-3 (dhcpServerAlreadyUsed)'
			traceback.print_exc (100, sys.stdout)
		else:
			exists=1
	except univention.admin.uexceptions.noLock:
		if not ignore_exists:
			print 'ERROR: Object exists-4 (noLock)'
			traceback.print_exc (100, sys.stdout)
		else:
			exists=1
	except univention.admin.uexceptions.mailAddressUsed:
		create_sub_object(o)

	return exists


def verify_containers (position_dn, module, co, lo, superordinate, base, path=""):
	"""
	verifies all containers starting at the ldap base

	@param	module	Param is ignored! cn_module is the only supported module!!
	"""
	split_dn = position_dn.split (',')
	# with this variable it's ensured that within a row of containers there is
	# no other object/container which can not be created with method
	started_cn_row = False
	for i in xrange (len (split_dn) -1, -1, -1):
		if split_dn[i].startswith ('cn='):
			verify_container (','.join (split_dn[i:]), cn_module, co, lo, superordinate, base, path=path)
			started_cn_row = True
		elif started_cn_row:
			# found an object/container that can not be created
			break

def verify_container(position_dn, module, co, lo, superordinate, base, path="userPath"):
	"""
	look if goal-container exists, else create it
	"""
	container_exists = 0
	type=position_dn[0:string.find(position_dn,"=")]
	name=position_dn[string.find(position_dn,"=")+1:string.find(position_dn,",")]
	position=position_dn[string.find(position_dn,",")+1:]
	objects=''
	try:
		objects = univention.admin.modules.lookup(module, co, lo, scope='sub', superordinate=superordinate, base=position,
												  filter=univention.admin.filter.expression(type,name))
		count_lo()
	except:
		pass
	if objects:
		for object in objects:
			if codecs.latin_1_encode(univention.admin.objects.dn(object))[0]==position_dn:
				container_exists = 1

	if not container_exists:
		print "need to create container %s"%position_dn
		position=univention.admin.uldap.position(base)
		position.setDn(position_dn[string.find(position_dn,",")+1:])
		object = module.object(co, lo, position, superordinate=superordinate)
		count_lo()
		object.open()
		object["name"] = position_dn[3:string.find(position_dn,",")]

		if position_dn[:2] == "cn" and path: # is path container
			object[path] = codecs.latin_1_encode("1")[0]

		exists = create_object(object)

def verify_group_share(schoolNr, classNr, co, lo, superordinate, base):

	if (schoolNr, classNr.lower()) in verified_group_shares:
		return True

	position_dn="cn=%s,cn=klassen,cn=shares,%s"%(classNr, getDN (schoolNr, basedn=base))
	module = univention.admin.modules.get("shares/share")
	more_instances = 1
	container_position = base
	while more_instances:
		container_position = position_dn[string.rfind(position_dn,",",0,len(position_dn)-len(container_position)-1)+1:]
		if container_position == position_dn:
			more_instances = 0
		elif container_position[:2] == "cn":
			verify_container(container_position, cn_module, co, lo, superordinate, base, path="groupPath")
		elif container_position[:2] == "ou":
			verify_container(container_position, ou_module, co, lo, superordinate, base)
		else: print "WARNING: unknown container type",container_position

	# look if share exists, else create it
	share_exists = 0
	type=position_dn[0:string.find(position_dn,"=")]
	name=position_dn[string.find(position_dn,"=")+1:string.find(position_dn,",")]
	position=position_dn[string.find(position_dn,",")+1:]
	objects = univention.admin.modules.lookup(module, co, lo, scope='sub', superordinate=superordinate, base=position,
											  filter=univention.admin.filter.expression(type,name))
	count_lo()
	if objects:
		for object in objects:
			if codecs.latin_1_encode(univention.admin.objects.dn(object))[0].lower() == position_dn.lower():
				share_exists = 1
	if not share_exists:
		print "need to create groupshare %s"%position_dn

		# get gid form corresponding group
		group_dn="cn=%s,cn=klassen,cn=%s,cn=groups,%s"%(classNr, cn_pupils, getDN (schoolNr, basedn=base))
		gids=lo.get(group_dn,['gidNumber'])
		count_lo()
		gid = 0
		if len(gids) > 1:
			print "WARNING: more than one corresponding gid found"
			gid=gids["gidNumber"][0]
		elif len(gids) < 1:
			print "WARNING: no corresponding gid found"
		else:
			gid=gids["gidNumber"][0]


		# set default server
		serverfqdn = "dc%s-01.%s"%(schoolNr.lower (),domainname)

		# get alternative server (defined at ou object if a dc slave is responsible for more than one ou)
		ou_dn = getDN (schoolNr, basedn=base)
		ou_attr_LDAPAccessWrite = lo.get(ou_dn,['univentionLDAPAccessWrite'])
		count_lo()
		alternativeServer_dn = None
		if len(ou_attr_LDAPAccessWrite) > 0:
			alternativeServer_dn = ou_attr_LDAPAccessWrite["univentionLDAPAccessWrite"][0]
			if len(ou_attr_LDAPAccessWrite) > 1:
				print "WARNING: more than one corresponding univentionLDAPAccessWrite found at ou=%s" % schoolNr

		# build fqdn of alternative server and set serverfqdn
		if alternativeServer_dn:
			alternativeServer_attr = lo.get(alternativeServer_dn,['uid'])
			count_lo()
			if len(alternativeServer_attr) > 0:
				alternativeServer_uid = alternativeServer_attr['uid'][0]
				alternativeServer_uid = alternativeServer_uid.replace('$','')
				if len(alternativeServer_uid) > 0:
					serverfqdn = "%s.%s" % (alternativeServer_uid, domainname)


		position=univention.admin.uldap.position(base)
		position.setDn(position_dn[string.find(position_dn,",")+1:])
		object = module.object(co, lo, position, superordinate=superordinate)
		count_lo()
		object.open()
		object["name"] = "%s"%classNr
		object["host"] = serverfqdn
		object["path"] = "/home/groups/klassen/%s"%classNr
		object["writeable"] = "1"
		object["sambaWriteable"] = "1"
		object["sambaBrowseable"] = "1"
		object["sambaForceGroup"] = "+%s"%classNr
		object["sambaCreateMode"] = "0770"
		object["sambaDirectoryMode"] = "0770"
		object["owner"]="0"
		object["group"]=gid
		object["directorymode"]="0770"

		exists = create_object(object)

	if not classNr in verified_group_shares:
		verified_group_shares.append((schoolNr, classNr.lower()))


def verify_group(position_dn, co, lo, superordinate, base):
	# look if group exists, else create it

	if position_dn in verified_groups:
		return True

	group_exists = 0
	type=position_dn[0:string.find(position_dn,"=")]
	name=position_dn[string.find(position_dn,"=")+1:string.find(position_dn,",")]
	position=position_dn[string.find(position_dn,",")+1:]

	more_instances = 1
	container_position = base
	while more_instances:
		container_position = position_dn[string.rfind(position_dn,",",0,len(position_dn)-len(container_position)-1)+1:]
		if container_position == position_dn:
			more_instances = 0
		elif container_position[:2] == "cn":
			verify_container(container_position, cn_module, co, lo, superordinate, base, path="groupPath")
		elif container_position[:2] == "ou":
			verify_container(container_position, ou_module, co, lo, superordinate, base)
		else: print "WARNING: unknown container type",container_position

	objects = univention.admin.modules.lookup(group_module, co, lo, scope='sub', superordinate=superordinate, base=position,
											  filter=univention.admin.filter.expression(type,name))
	count_lo()
	if objects:
		for object in objects:
			if codecs.latin_1_encode(univention.admin.objects.dn(object))[0].lower() == position_dn.lower():
				group_exists = 1

	if not group_exists:
		print "need to create group %s"%position_dn
		position=univention.admin.uldap.position(base)
		position.setDn(position_dn[string.find(position_dn,",")+1:])
		object = group_module.object(co, lo, position, superordinate=superordinate)
		count_lo()
		object.open()
		object["name"] = position_dn[3:string.find(position_dn,",")]


		exists = create_object(object)

	if not position_dn in verified_groups:
		verified_groups.append(position_dn)

def delete_dn(dn, module, co, lo):
	position.setDn(dn[string.find(dn,",")+1:])
	object=univention.admin.objects.get(module, co, lo, position=position, dn=dn)
	count_lo()
	object.open()
	try:
		object.remove()
		print "deleted:",dn
		return ""
	except univention.admin.uexceptions.noObject:
		print "ERROR: delete this user manually (not found):",dn
		traceback.print_exc (100, sys.stdout)
		return "ERROR: delete this user manually (not found): "+dn+"\n"
	except:
		print "ERROR: delete this user manually (maybe not found):",dn
		traceback.print_exc (100, sys.stdout)
		return  "ERROR: delete this user manually (maybe not found):"+dn+"\n"

def delete_user(person, module, co, lo):

	# search all objects with univentionAbordnungMaster == dn of the person
	# we want to delete, make one of them to the new master account
	# (set primaryMailAddress and remove univentionAbordnungMaster attribute
	# and univentionAbordnung objectclass) and change dn in univentionAbordnungMaster
	# in the rest
	dn = person.getDN()
	mail = person.mail
	base = person.getPosition_dn()
	uid = person.login
	newdn = ""

	# get primaryMail from account
	master = lo.search(base=base, filter="(uid=%s)" % uid, attr=['mailPrimaryAddress'])
	if master:
		tmpdn, attr = master[0]
		if attr.has_key("mailPrimaryAddress") and attr['mailPrimaryAddress']:
			mail = attr['mailPrimaryAddress']

	# delete account
	person.problem_hints += delete_dn(person.getDN(),module,co,lo)

	# search sub accounts
	result = lo.search(filter='(univentionAbordnungMasterDn=%s)' % dn, attr=['objectClass'])

	# first sub account becomes new master account
	if result:
		newdn, attr = result[0]
		ocs = []
		for i in attr['objectClass']:
			if not i == "univentionAbordnung": ocs.append(i)
		ml = []
		ml.append(('objectClass', attr['objectClass'], ocs))
		ml.append(("mailPrimaryAddress", None, mail))
		ml.append(("univentionAbordnungMasterDn", dn, ""))
		try:
			lo.modify(newdn, ml)
		except:
			person.problem_hints += "problems while making " + newdn + " a master account\n"
		del result[0]

	# modify sub accounts
	for i in result:
		subdn, attr = i
		ml = []
		ml.append(("univentionAbordnungMasterDn", dn, newdn))
		try:
			lo.modify(subdn, ml)
		except:
			person.problem_hints += "problems while setting new master dn to sub account " + subdn + "\n"

def modify_user(person, module, co, lo):
	default_groups = person.default_groups()
	object=univention.admin.objects.get(module, co, lo, position='', dn=person.getDN(), arg='')
	count_lo()
	object.open()
	object["username"]=person.login
	object["primaryGroup"]=default_groups[0]
	object["unixhome"]="/home/"+person.login
	object["firstname"]=person.name
	object["lastname"]=person.sname
	object["e-mail"]=person.mail
	if object.has_key('mailPrimaryAddress'):
		object['mailPrimaryAddress']=person.mail
	if person.isActive == "1":
		object["disabled"]="0"
	else:
		object["disabled"]="1"
	# ATTENTION: it's not possible to change the ucsschool-user-role with the
	# import script

	remove_groups = []
	for group in object['groups']:
		if group not in default_groups:
			kpos = string.find(group,',')
			if group[:9] == ('cn=%s' % cn_pupils) or \
					group[:11] == ('cn=%s' % cn_teachers) or \
					group[kpos+1:kpos+23] == ('cn=klassen,cn=%s' % cn_pupils):
				# group looks like a default group, so we don't need it anymore
				print "remove from group: %s"%group
				remove_groups.append(group)
	for group in remove_groups:
		object['groups'].remove(group)

	for group in default_groups:
		if group not in object["groups"]:
			object["groups"].append(group)
			verify_group(group, co, lo, superordinate, baseDN)
			print "need to add group %s"%group

	#print "user is in groups: %s" % object['groups']

	for cnr in person.cNr:
		verify_group_share(person.sNr,cnr,co,lo,superordinate,baseDN)

	try:
		object.modify()
		o_sNr=lo.search(base=person.getDN(), scope='base', attr=['departmentNumber'])
		count_lo()
		if not o_sNr == person.allsNrs:
			lo.modify(person.getDN(),[("departmentNumber",o_sNr,person.allsNrs)])
			count_lo()
		print "modified:",person.getDN()
	except:
		print "ERROR:", sys.exc_info()[0], sys.exc_info()[1]
		traceback.print_exc (100, sys.stdout)
		print "modify this user manually:",person.getDN()
		person.problem_hints = person.problem_hints + "modify this user manually: "+person.getDN()+"\n"


def check_user(person, baseDN, module):
	objects = univention.admin.modules.lookup(module, co, lo, scope='sub', superordinate=superordinate, base=person.getPosition_dn(),
											  filter=univention.admin.filter.expression('uid',person.login))
	count_lo()
	user_exists=0
	if objects:
		for object in objects:
			if object.dn == person.getDN():
				user_exists = 1
	return user_exists

def get_passwd():
	makepasswd = os.popen('makepasswd --chars=8')
	return makepasswd.readline()[:-1] # without newline

def create_passwd():
	charlistA = 'abcdefghijklmnopqrstuvwxyz'
	charlistB = '0123456789'
	passwd=''
	passwd += charlistA[ random.randrange(0,len(charlistA)) ] + charlistA[ random.randrange(0,len(charlistA)) ]
	passwd += charlistB[ random.randrange(0,len(charlistB)) ] + charlistB[ random.randrange(0,len(charlistB)) ]
	passwd += charlistA[ random.randrange(0,len(charlistA)) ] + charlistA[ random.randrange(0,len(charlistA)) ]
	return passwd

def create_user(person, baseDN, module, password):
	if generate_logins:
		try:
			loginname = person.login
			i = 1
			while(check_user(person, baseDN, user_module)):
				print "WARING: User already exists: %s"%person.getDN()
				person.problem_hints +="WARNING: Username already exists: %s" % person.getDN()+" appended counted number\n"
				person.login = loginname+str(i)
				print "INFO: Trying with new username: ", person.login
				i = i+1
		except: # happens if container does not exsist
			pass

	# check if ou exists at all
	objects = univention.admin.modules.lookup(ou_module, co, lo, scope='sub', superordinate=superordinate, base=baseDN,
										  filter=univention.admin.filter.expression('ou',person.sNr))
	count_lo()
## 	ou_exists=0
## 	if objects:
## 		for object in objects:
## 			if codecs.latin_1_encode(univention.admin.objects.dn(object))[0]==(getDN (person.sNr)):
## 				ou_exists = 1
## 	if not ou_exists:
	verify_school_ou(person.sNr, co, lo, baseDN)
	# check if needed subtree exists, this should not be neccessary be after verify of the ou but we may crash if someone makes changes by hand
	more_instances = 1
	container_position = baseDN
	while more_instances:
		container_position = person.getPosition_dn()[string.rfind(person.getPosition_dn(),",",0,
															  len(person.getPosition_dn())-len(container_position)-1)+1:]
		if container_position == person.getPosition_dn():
			more_instances = 0
		if container_position[:2] == "cn":
			verify_container(container_position, cn_module, co, lo, superordinate, baseDN)
		elif container_position[:2] == "ou":
			verify_container(container_position, ou_module, co, lo, superordinate, baseDN)
		else: print "WARNING: unknown container type",container_position


	groups = person.default_groups()
	for group in groups:
		verify_group(group, co, lo, superordinate, baseDN)
	for cnr in person.cNr:
		verify_group_share(person.sNr,cnr,co,lo,superordinate,baseDN)

	position=univention.admin.uldap.position(baseDN)
	position.setDn(person.getPosition_dn())

	object=user_module.object(co, lo, position=position, superordinate=superordinate)
	count_lo()
	object.open()

	object["username"]=person.login
	object["primaryGroup"]=groups[0]
	if len(groups) > 1:
		object["groups"]=groups[1:]
	object["unixhome"]="/home/"+person.login
	if object.has_key('mailbox'):
		object["mailbox"]="/var/spool/%s/"%person.login
	object["password"]=password
	object["firstname"]=person.name
	object["lastname"]=person.sname
	object["e-mail"]=person.mail
	if object.has_key('mailPrimaryAddress'):
		object['mailPrimaryAddress']=person.mail
	if person.isActive == "1":
		object["disabled"]="0"
	else:
		object["disabled"]="1"
	object["ucsschool-user-role"]=person.getRole ()
	object["pwdChangeNextLogin"]="0"

	try:
		if not create_object(object) == "1":
			lo.modify(person.getDN(),[("departmentNumber",[],person.allsNrs)])
			count_lo()
			print "created:",person.getDN()
			created_users[person.login]=password
		else:
			print "ERROR: there were problems creating this user:",person.getDN()
			person.problem_hints = person.problem_hints + "ERROR: there were problems creating this user: "+person.getDN()+"\n"

	except:
		print "ERROR:", sys.exc_info()[0], sys.exc_info()[1]
		print "ERROR: create this user manually:",person.getDN()
		traceback.print_exc (100, sys.stdout)
		person.problem_hints = person.problem_hints + "ERROR: create this user manually: " + person.getDN()+"\n"

	return 1

def import_user():
	# argument is infile
	if len(sys.argv)>1:
		infile = sys.argv[1]
	else:
		print "must have one Argument for infile"
		sys.exit()

	print "infile is  : "+infile
	inf = open(infile,'r')

	# outfile for passwords of created users
	outfile = None
	#outfile = "/var/lib/ucs-school-import/create-user-passwd-%s.csv" % time.strftime("%Y%m%d-%H%M%S")
	#outf = open(outfile,'w')

#	if len(sys.argv)>2:
#		outfile = sys.argv[2]
#		print "outfile is : ./"+outfile
#		if os.path.exists(outfile):
#			print 'outfile %s does already exist. Stopping here.' % outfile
#			sys.exit()
#		outf = open(outfile,'w')

	problem_hints=""
	passwd_used=1
	linecnt=0

	line=inf.readline()
	while not line=="":
		linecnt += 1
		print 'Processing line %d: %s' % (linecnt, line),
		try:
			main_person = ucsschool_person_modify(line)
		except:
			msg = 'ERROR: Problems parsing line, skipped: %d: %s' % (linecnt, line)
			print msg
			traceback.print_exc (100, sys.stdout)
			problem_hints += msg + '\n'
			## read next line
			line = inf.readline()
			continue

		persons = [main_person]
		persons.extend(main_person.getOtherPersons())
		#passwd = create_passwd()
		#passwd = get_passwd()
		passwd = '12345678'

		if main_person.modtype == "A":
			#if passwd_used:
			#	passwd=''
			#	passwd_used=0
			for person in persons:
				try:
					#if passwd=='':
					#	create password, only if not already done. So one user has the same initial passwd in all his accounts
					#	passwd=get_passwd()
					#	passwd_used=0
					#if create_user(person, baseDN, user_module, passwd):
					#	passwd_used=1
					result = create_user(person, baseDN, user_module, passwd)
					if result and outfile:
						outf.write('%s\t%s\t%s\t%s\t%s\t%s\t%s\n' % (person.sNr, ','.join(person.cNr), person.sname, person.name, passwd, person.mail, person.login))
				except:
					msg = "ERROR: There were problems creating this user: " + str(person.getDN())
					print msg
					traceback.print_exc (100, sys.stdout)
					person.problem_hints += msg + "\n"

		elif main_person.modtype in ["M","D"]:
			# look if there are exsiting persons in other ou's remaining, this will fail if the users's departmentNumbers
			# are changed manually
			filter=univention.admin.filter.conjunction("|",[univention.admin.filter.expression('uid',"%s_*"%main_person.login),
															univention.admin.filter.expression('uid',"%s"%main_person.login)])
			objects = univention.admin.modules.lookup(user_module, co, lo, scope='sub', superordinate=superordinate, base=baseDN,
											  filter=filter)
			count_lo()
			found = []
			for object in objects:
				ou=object.dn[string.find(object.dn,"ou=")+3:string.find(object.dn,",",string.find(object.dn,"ou=")+3)]
				# get from LDAP the user type: teacher, staff or student
				main_person.isTeacher = '0'
				main_person.isStaff   = '0'
				if role_teacher in object['ucsschool-user-role']:
					main_person.isTeacher = '1'
				elif role_staff in object['ucsschool-user-role']:
					main_person.isStaff = '1'

				if ou in main_person.allsNrs:
					found.append(ou)
				else:
					main_person.problem_hints += "delete unmentioned user %s \n"%object.dn
					main_person.problem_hints += delete_dn(object.dn,user_module,co,lo)

			for person in persons:
				if person.modtype == "M":
					if person.sNr in found:
						try:
							modify_user(person, user_module, co, lo)
						except:
							msg = "ERROR: There were problems modifying this user: "  + str(person.getDN())
							print msg
							traceback.print_exc (100, sys.stdout)
							person.problem_hints += msg + "\n"
					else:
						try:
							print "WARNING: user to modify not found, ",
							result = create_user(person, baseDN, user_module, passwd)
							if result and outfile:
								outf.write('%s\t%s\t%s\t%s\t%s\t%s\t%s\n' % (person.sNr, ','.join(person.cNr), person.sname, person.name, passwd, person.mail, person.login))
						except:
							msg = "ERROR: There were problems creating this user: "  + str(person.getDN())
							print msg
							traceback.print_exc (100, sys.stdout)
							person.problem_hints += msg + "\n"

				else: # main_person.modtype == "D":
					# NOTE: there is no need for this try-catch-block because delete_dn handles exceptions by itself
					#try:
					delete_user(person, user_module, co, lo)
					#except:
						#msg = "There were problems deleting this user:" , person.getDN()
						#print msg
						#traceback.print_exc (100, sys.stdout)
						#person.problem_hints += msg + "\n"

				main_person.problem_hints += person.problem_hints
		else:
			print "WARNING: unknown operation type:",main_person.modtype
			main_person.problem_hints += "unknown operation type for this user: "+main_person.getDN()+"\n"

		problem_hints += main_person.problem_hints

		#print 'Processing of line %d completed' % linecnt

		# read next line
		line=inf.readline()

	if outfile:
		outf.close()

	# report created users
	message=""
	#if not created_users.keys() == []:
	#	message = "The following Users/Passwords were created. Please change the Password immediatly !\n\n\n"
	#	for el in created_users.keys():
	#		message = message+ el + " - " + created_users[el] +"\n"

	if not problem_hints == "":
		message = message + "\n\nProblems during last run:\n\n" + problem_hints

	print message

def create_network(schoolNr, network, iprange=None, defaultrouter=None, nameserver=None, netbiosserver=None):
	"""
	@param	network	The network address MUST contain the netmask!! it could also be a ipaddr.IPv4 object
	@param	defaultrouter	IP-Adress, if no netmask is profided it's derived from network
	@param	nameserver	IP-Adress, if no netmask is profided it's derived from network
	@param	netbiosserver	IP-Adress, if no netmask is profided it's derived from network
	"""

	verify_school_ou(schoolNr, co, lo, baseDN)


	if check_network(schoolNr, network):
		print "Network %s/%d exists in school %s!"%(network.network_ext, network.prefixlen, schoolNr)
		return

	print "generate network %s/%d" % (network.network_ext, network.prefixlen)
	if iprange:
		print "iprange: %s-%s" % (iprange[0].ip_ext, iprange[1].ip_ext)
	if defaultrouter:
		print "defaultrouter: %s" % defaultrouter
	if nameserver:
		print "nameserver: %s" % nameserver
	if netbiosserver:
		print "netbiosserver: %s" % netbiosserver

	# WORKAROUND for Bug #14795
	subnetbytes = 0
	tmp = network.netmask_ext.split ('.')
	for i in tmp:
		if i == '255':
			subnetbytes += 1
		else:
			break
	subnet = '.'.join (network.network_ext.split ('.')[:subnetbytes])
	# END WORKAROUND

	position.setDn("cn=dns,%s"%(baseDN))
	object=dns_reverse_zone_module.object(co, lo, position=position, superordinate=superordinate)
	count_lo()
	object.open()
	object['subnet']     = subnet
	# the nameserver/SOA at the dns_reverse_zone object is always the ldap/master server!
	object['nameserver'] = configRegistry['ldap/master']
	object['contact']    = 'root@%s'%domainname
	create_object(object, ignore_exists=1)

	position.setDn("cn=%s,cn=dhcp,%s"%(schoolNr.lower (), getDN (schoolNr)))
	object=dhcp_service_module.object(co, lo, position=position, superordinate=superordinate)
	count_lo()
	object=dhcp_subnet_module.object(co, lo, position=position, superordinate=dhcp_subnet_module)
	count_lo()
	object.open()
	object['subnet']=network.network_ext
	object['subnetmask']=network.netmask_ext
	object['broadcastaddress']=network.broadcast_ext
	create_object(object)

	position.setDn("cn=networks,%s" % (getDN (schoolNr), ))
	object=network_module.object(co, lo, position=position, superordinate=superordinate)
	count_lo()
	object.open()
	object['name']='%s-%s'%(schoolNr.lower (), network.network_ext)
	object['netmask']=str (network.prefixlen)
	object['network']=network.network_ext
	object['ipRange']=[[iprange[0].ip_ext, iprange[1].ip_ext]]
	object['dhcpEntryZone']='cn=%s,cn=dhcp,%s'%(schoolNr.lower (), getDN (schoolNr))
	object['dnsEntryZoneForward']='zoneName=%s,cn=dns,%s'%(domainname, baseDN)
	object['dnsEntryZoneReverse']='zoneName=%s.in-addr.arpa,cn=dns,%s'%('.'.join (reversed (subnet.split ('.'))),baseDN)
	create_object(object)

	# set netbios and router for dhcp subnet
	if defaultrouter:
		print 'setting default router'
		set_router_for_subnet (network, defaultrouter, schoolNr)

	if netbiosserver:
		print 'setting netbios server'
		set_netbiosserver_for_subnet (network, netbiosserver, schoolNr)

	# set default value for nameserver
	if nameserver:
		print 'setting nameserver'
		set_nameserver_for_subnet (network, nameserver, schoolNr)


def check_network(schoolNr, network):
	"""
	@param	network	ipaddr.IPv4 object
	"""
	objects = univention.admin.modules.lookup(network_module, co, lo, scope='sub', superordinate=superordinate,
											  base='cn=networks,%s'%(getDN (schoolNr)),
											  filter=univention.admin.filter.expression('cn','%s-%s'%(schoolNr.lower (), network.network_ext)))
	count_lo()
	network_exists=0
	if objects:
		n = "cn=%s-%s,cn=networks,%s"%(schoolNr.lower (), network.network_ext, getDN (schoolNr))
		for object in objects:
			if object.dn == n:
				network_exists = 1

	return network_exists

def check_macAddress(mac,base=''):
	if not base:
		base=baseDN
	result=lo.search(base=base, scope='sub',filter='(macAddress=%s)'%mac,attr=['macAddress'])
	count_lo()

	if result and result[0][1]['macAddress'][0]==mac:
		return result[0][0]

def generate_new_mac(schoolNr,IP):
	ipnum=string.replace(IP,'.','')
	if IP:
		mac_start = '%s:%s:%s:%s:'%(schoolNr[:2],schoolNr[-2:],ipnum[:2],ipnum[-2:])
	else:
		mac_start = '%s:%s:00:00:'%(schoolNr[:2],schoolNr[-2:],ipnum[:2],ipnum[-2:])
	mac='%s00:00'%mac_start
	i=10
	j=10
	while check_macAddress(mac,base='cn=computers,%s' % (getDN (schoolNr), )):
		if i==99:
			i=10
			j+=1
		else:
			i+=1
		mac='%s%s:%s'%(mac_start,i,j)

	return mac

def check_computer(module, name, schoolNr):
	objects = univention.admin.modules.lookup(module, co, lo, scope='sub', superordinate=superordinate,
											  base='cn=computers,%s' % (getDN (schoolNr), ),
											  filter=univention.admin.filter.expression('cn','%s'%name))
	count_lo()
	computer_exists=0
	if objects:
		for object in objects:
			if object.dn == "cn=%s,cn=computers,%s"%(name, getDN (schoolNr)):
				computer_exists = 1

	return computer_exists

def get_computer_dn(name):
	module = univention.admin.modules.get("computers/computer")
	objects = univention.admin.modules.lookup(module, co, lo, scope='sub', superordinate=superordinate, filter=univention.admin.filter.expression('cn','%s'%name))
	if objects:
		for object in objects:
			if object.dn.startswith("cn=%s," %name):
				return object.dn
	return None

def import_networks(router_only=False):
	# argument is infile
	if len(sys.argv)>1:
		infile = sys.argv[1]
	else:
		print "must have one Argument for infile"
		sys.exit()

	print "infile is  : "+infile
	inf = open(infile,'r')

	problem_hints=""

	line=inf.readline()
	while not line == "":

		parsed=line[:-1].split(sepchar)

		schoolNr      = parsed[0]
		# the network MUST include the netmask
		network       = parsed[1] # netmask new
		# the broadcast address is generated automatically by the
		# combination of network and netmask
		iprange       = parsed[2] # new
		defaultrouter = parsed[3] # new
		nameserver    = parsed[4] # new
		netbiosserver = parsed[5] # new

		# convert parameters to ipaddr.IPv4
		network = ipaddr.IPv4 (network)
		if network.prefixlen == 32:
			print 'ERROR: no netmask specified for network %s' % network.network_ext
			line=inf.readline()
			continue

		tmp = iprange.split ('-')
		if len (tmp) != 2:
			print 'ERROR: IP host range not valid: %s' % iprange
			line=inf.readline()
			continue
		iprange = (ipaddr.IPv4 (tmp[0]), ipaddr.IPv4 (tmp[1]))
		if iprange[0].ip < network.network + 1 \
				or iprange[0].ip > iprange[1].ip \
				or iprange[1].ip >= network.broadcast:
			print 'ERROR: IP host range not valid: %s' % iprange
			line=inf.readline()
			continue

		defaultrouter = ipaddr.IPv4 (defaultrouter)
		nameserver = ipaddr.IPv4 (nameserver)
		netbiosserver = ipaddr.IPv4 (netbiosserver)

		if router_only:
			set_router_for_subnet (network, defaultrouter, schoolNr, overwrite_policy=True)
			print 'Router set for subnet.'
		else:
			create_network(schoolNr, network, \
					iprange=iprange, \
					defaultrouter=defaultrouter, \
					nameserver=nameserver, \
					netbiosserver=netbiosserver)

		# read next line
		line=inf.readline()

def set_inventory_number_for_computer():
	# argument is infile
	if len(sys.argv)>1:
		infile = sys.argv[1]
	else:
		print "must have one Argument for infile"
		sys.exit()

	print "infile is  : "+infile
	inf = open(infile,'r')

	problem_hints=""

	line=inf.readline()
	while not line == "":

		parsed=line.split(sepchar)
		ctype    = parsed[0]
		name     = parsed[1]
		MAC      = parsed[2]
		inventoryNumbers = parsed[3].strip().split(',')

		dn = get_computer_dn(name)
		if not dn:
			print "Computer to modify not found: %s" % name
			problem_hints = problem_hints + "Computer to modify not found: %s" % name
		else:
			try:
				computerModule = univention.admin.modules.get("computers/%s"%ctype)
			except:
				print "failed to get module of type computers/%s" % ctype
				traceback.print_exc (100, sys.stdout)
				problem_hints = problem_hints + "failed to get module of type computers/%s" % ctype
				line=inf.readline()
				continue
			computerObject = univention.admin.objects.get(computerModule, co, lo, position='', dn=dn, arg='')
			computerObject.open()
			if MAC.replace('-',':').replace(' ',':').lower() in computerObject['mac']:
				try:
					computerObject['inventoryNumber'] = inventoryNumbers
					computerObject.modify()
					print "modified inventory Number for %s" % dn
				except:
					print "failed to modify computer %s" % name
					traceback.print_exc (100, sys.stdout)
					problem_hints = problem_hints + "failed to modify computer %s" % name
			else:
				print "mac address does not match while modifying %s" % name
				problem_hints = problem_hints + "mac address does not match while modifying %s" % name

		line=inf.readline()

def set_policy_for_dhcp_subnet (network, schoolNr, policy_module, policy_dn, cn, values={}, overwrite_policy=False):
	"""
	@param	network	network where policy object shall be added
	@param	schoolNr	school number
	"""
	# check if routing policy needs to be created
	so = "cn=%s,cn=dhcp,%s" % (schoolNr.lower (), getDN (schoolNr))
	objects = univention.admin.modules.lookup(dhcp_subnet_module, co, lo, scope='sub', superordinate=so,
			base=baseDN, filter=univention.admin.filter.expression('cn', network.network_ext))
	count_lo()
	dhcp_subnet_object=None
	subnet = "cn=%s,cn=%s,cn=dhcp,%s" % (network.network_ext, schoolNr.lower (), getDN (schoolNr))
	if objects:
		for o in objects:
			if o.dn == subnet:
				dhcp_subnet_object = o
	if not dhcp_subnet_object:
		print "ERROR: Unable to set policy for dhcp subnet because it does not exist: %s" % subnet
		return

	objects = univention.admin.modules.lookup(policy_module, co, lo, scope='sub', superordinate=superordinate,
			base=baseDN, filter=univention.admin.filter.expression('cn', cn))
	policy_object = None
	if objects:
		for o in objects:
			if o.dn == policy_dn:
				policy_object = o
	if not policy_object:
		position_dn = ','.join (policy_dn.split (',')[1:])
		verify_containers (position_dn, cn_module, co, lo, superordinate, baseDN, path='policyPath')
		position.setDn (position_dn)
		policy_object = policy_module.object(co, lo, position=position, superordinate=superordinate)
		count_lo()
		policy_object.open()
		for k, v in values.iteritems ():
			policy_object[k] = v
		try:
			create_object(policy_object)
		except:
			print "WARNING: Error creating policy %s" % policy_object.dn
			traceback.print_exc (100, sys.stdout)
			policy_object = None
	elif overwrite_policy:
		policy_object.open ()
		for k, v in values.iteritems ():
			policy_object[k] = v
		try:
			policy_object.modify ()
		except:
			print "WARNING: Error modifying policy %s" % policy_object.dn
			traceback.print_exc (100, sys.stdout)
			policy_object = None

	if policy_object:
		# add policy reference to dhcp_subnet_object
		try:
			lob = lo.get (dhcp_subnet_object.dn, ['objectClass'])
			if 'univentionPolicyReference' not in lob.get ('objectClass', []):
				lo.modify (dhcp_subnet_object.dn, [ ('objectClass','','univentionPolicyReference') ])

			lob = lo.get (dhcp_subnet_object.dn, ['univentionPolicyReference'])
			if policy_object.dn not in lob.get ('univentionPolicyReference', []):
				print 'connecting dhcp subnet (%s) with policy (%s)' % (dhcp_subnet_object.dn, policy_object.dn)
				lo.modify (dhcp_subnet_object.dn, [ ('univentionPolicyReference','',policy_object.dn) ])
		except:
			print "WARNING: Error modifying policy %s" % policy_object.dn
			traceback.print_exc (100, sys.stdout)
			policy_object = None

def set_netbiosserver_for_subnet (network, ip, schoolNr, overwrite_policy=False):
	"""
	@param	ip	ipaddr object for the netbios server
	@param	schoolNr	school number

	The Netbios node type is set to 8 H-node: Hybrid - WINS, then broadcast
	"""
	values = {
			'name':'%s-%s' % (schoolNr.lower (), network.network_ext),
			'netbios_node_type':'8',
			'netbios_name_servers':ip.ip_ext}
	dn = "cn=%s,cn=netbios,cn=dhcp,cn=policies,%s" % (values['name'], getDN (schoolNr))
	set_policy_for_dhcp_subnet (network, schoolNr, policy_dhcp_netbios_module, dn, values['name'], values=values, overwrite_policy=overwrite_policy)

def set_nameserver_for_subnet (network, ip, schoolNr, overwrite_policy=False):
	"""
	@param	ip	ipaddr object for the netbios server
	@param	schoolNr	school number
	"""
	values = {
			'name':'%s-%s' % (schoolNr.lower (), network.network_ext),
			'domain_name':domainname,
			'domain_name_servers':ip.ip_ext}
	dn = "cn=%s,cn=dns,cn=dhcp,cn=policies,%s" % (values['name'], getDN (schoolNr))
	set_policy_for_dhcp_subnet (network, schoolNr, policy_dhcp_dns_module, dn, values['name'], values=values, overwrite_policy=overwrite_policy)

def set_router_for_subnet (network, ip, schoolNr, overwrite_policy=False):
	"""
	@param	ip	ipaddr object for the router
	@param	schoolNr	school number
	"""
	values = {
			'name':'%s-%s' % (schoolNr.lower (), network.network_ext),
			'routers':ip.ip_ext}
	dn = "cn=%s,cn=routing,cn=dhcp,cn=policies,%s" % (values['name'], getDN (schoolNr))
	set_policy_for_dhcp_subnet (network, schoolNr, policy_dhcp_routing_module, dn, values['name'], values=values, overwrite_policy=overwrite_policy)

def import_computer():
	# argument is infile
	if len(sys.argv)>1:
		infile = sys.argv[1]
	else:
		print "must have one Argument for infile"
		sys.exit()

	print "infile is  : "+infile
	inf = open(infile,'r')

	problem_hints=""
	linecnt=0

	line=inf.readline()
	while not line=="":
		linecnt += 1
		print 'Processing line %d: %s' % (linecnt, line),

		parsed=line.split(sepchar)

		ctype = parsed[0]
		name  = parsed[1].lower ()
		MAC      = parsed[2]
		schoolNr = parsed[3]
		IP       = parsed[4] # netmask needed, new
		inventoryNumbers = parsed[5].strip().split(',')

		verify_school_ou(schoolNr, co, lo, baseDN)

		ip = ipaddr.IPv4 (IP)

		module = univention.admin.modules.get("computers/%s"%ctype)
		if not module:
			print 'ERROR: Type "%s" not found for computer "%s".' % (ctype, name)
			print 'Ignoring of line %d' % linecnt
		else:
			if check_computer(module,name,schoolNr):
				print "computer %s already exists (school %s)"%(name,schoolNr)
			else:
				mac_used=check_macAddress(MAC)
				if mac_used:
					old_mac=MAC
					MAC=generate_new_mac(schoolNr, ip.ip_ext)
					print 'mac %s already used, set mac to %s (resolve manually)'%(old_mac,MAC)

				print "generate computer %s (school %s)"%(name,schoolNr)

				create_network(schoolNr, ip)

				position.setDn("cn=computers,%s" % (getDN (schoolNr), ))
				object=module.object(co, lo, position=position, superordinate=superordinate)
				count_lo()
				object.open()
				object['name'] = name
				object['mac']  = MAC
				# FIXME: Bug #14789 in UDM - network has to be set after
				# the objekt has been created
				#object['network']='cn=%s-%s,cn=networks,%s'%(schoolNr.lower (), ip.network_ext, getDN (schoolNr))
				object['inventoryNumber']=inventoryNumbers
				if not ip.ip == ip.network:
					object['ip'] = ip.ip_ext
					print "set ip to %s is not net %s" % (ip.ip_ext, ip.network_ext)
				try:
					create_object(object)

					try:
						# FIXME: because of Bug #14789 network has to be set here
						object = univention.admin.objects.get (module, co, lo, position='', dn="cn=%s,cn=computers,%s" % (name, getDN (schoolNr)), arg='')
						object.open ()
						object['network'] = 'cn=%s-%s,cn=networks,%s' % (schoolNr.lower (), ip.network_ext, getDN (schoolNr))
						object.modify ()
					except:
						print "WARNING: Error setting network for computer %s"%object.dn
						traceback.print_exc (100, sys.stdout)
				except:
					print "WARNING: Error creating computer %s"%object.dn
					traceback.print_exc (100, sys.stdout)

			print 'Processing of line %d completed' % linecnt

		# read next line
		line=inf.readline()

def import_router():
	"""
	No computer object is created on importing routers! But the dhcp-routing
	policy is set to the IP address of the router
	"""
	import_networks (router_only=True)

def import_group():
	# argument is infile
	if len(sys.argv)>1:
		infile = sys.argv[1]
	else:
		print "must have one Argument for infile"
		sys.exit()

	print "infile is  : "+infile
	inf = open(infile,'r')

	problem_hints=""

	line=inf.readline()[:-1]
	while not line=="":

		parsed=line.split(sepchar)

		action = parsed[0]   # action=A(dd, M(odify, D(elete
		schoolNr = parsed[1]
		ClassID = parsed[2]
		Descrpt = parsed[3]

		group_dn="cn=%s,cn=klassen,cn=%s,cn=groups,%s"%(ClassID, cn_pupils, getDN (schoolNr))
		share_dn="cn=%s,cn=klassen,cn=shares,%s"%(ClassID, getDN (schoolNr))

		if action in ['A','M']:	# Add/Modify group
## 			verify_group(group_dn, co, lo, superordinate, baseDN)
## 			object = univention.admin.objects.get(group_module, co, lo, position='', dn=group_dn, arg='')
## 			object.open()
## 			object['description']=Descrpt
## 			object.modify()
## 			verify_group_share(schoolNr, ClassID, co, lo, superordinate, baseDN)


## 		elif action == 'M':	# M)odify group
			verify_group(group_dn, co, lo, superordinate, baseDN)
			object = univention.admin.objects.get(group_module, co, lo, position='', dn=group_dn, arg='')
			count_lo()
			object.open()
			oldDescrpt = object['description']
			object['description']=Descrpt
			print "Changed Description of %s from %s to %s"%(group_dn, oldDescrpt, Descrpt)
			object.modify()
			verify_group_share(schoolNr, ClassID, co, lo, superordinate, baseDN)

		elif action == 'D':	# D)elete group
			delete_dn(group_dn, group_module, co, lo)
			delete_dn(share_dn, group_module, co, lo)


		line=inf.readline()[:-1]

def import_printer():
	# argument is infile
	if len(sys.argv)>1:
		infile = sys.argv[1]
	else:
		print "must have one Argument for infile"
		sys.exit()

	print "infile is  : "+infile
	inf = open(infile,'r')

	line=inf.readline()[:-1]
	while not line=="":

		parsed=line.split(sepchar)

		# completely new
		action = parsed[0]   # action=A(dd, M(odify, D(elete
		schoolNr = parsed[1]
		spoolHost = parsed[2].lower ()
		if '.' not in spoolHost:
			spoolHost = '%s.%s' % (spoolHost, configRegistry['domainname'])
		printerName = parsed[3]
		printerUri = parsed[4]
		printerModel = parsed[5]
		printerWindowsDriver = parsed[6]

		position_dn ="cn=%s,cn=printers,%s" % (printerName, getDN (schoolNr))
		container ="cn=printers,%s" % (getDN (schoolNr), )

		objects=''
		try:
			objects = univention.admin.modules.lookup(printer_module, co, lo, scope='sub', superordinate=superordinate, base=container,
													  filter=univention.admin.filter.expression(type,name))
			count_lo()
		except:
			pass
		if objects:
			for object in objects:
				if codecs.latin_1_encode(univention.admin.objects.dn(object))[0]==position_dn:
					container_exists = 1

		if action in ['A','M']: # Add/Modify printer
			position=univention.admin.uldap.position(baseDN)
			position.setDn(container)
			if action == 'A':
				object = printer_module.object(co, lo, position, superordinate=superordinate)
			else:
				object = univention.admin.objects.get(printer_module, co, lo, position='', dn=position_dn, arg='')
			count_lo()
			object.open()
			object['name'] = printerName
			object['spoolHost'] = [spoolHost]
			object['setQuota'] = '0' # WORKAROUND for Bug #14858
			object['uri'] = printerUri
			if printerModel:
				object['model'] = printerModel
			else:
				object['model'] = 'None'
			if printerWindowsDriver:
				object['univentionWinPrintDrvName'] = printerWindowsDriver
			if action == 'A':
				create_object (object)
			else:
				try:
					print 'modifying object %s' % position_dn
					object.modify()
				except:
					traceback.print_exc (100, sys.stdout)

		elif action == 'D':	# D)elete printer
			delete_dn(position_dn, printer_module, co, lo)


		line=inf.readline()[:-1]

def activate_groupmembers():
	#  syntax: $0 <groupXXX> [0|1] [0|1]"
	# <groupXXX>    group
	# [0|1]         optional: deactivate | activate
	# [0|1]         optional: keep passwords | set random passwords

	chgrp = 1
	chpasswd = 0
	status = None

	if len(sys.argv) < 2:
		print 'must have at least one argument'
		print 'activate_groupmembers <groupXXX> <newStatus> <changePassword>'
		print ''
		print '<groupXXX>        group that shall be dis-/enabled'
		print '<newstatus>       0=disabled, 1=enabled'
		print '<changePassword>  0=keep passwords, 1=set random passwords'
		print '                  the logfile groupXXX.csv contains all activated users'
		sys.exit()
	if len(sys.argv) > 1:
		actgrp = sys.argv[1]
	if len(sys.argv) > 2:
		status = int(sys.argv[2])
	if len(sys.argv) > 3:
		chpasswd = int(sys.argv[3])

	if status not in [0,1]:
		print 'invalid value for <newstatus>!'
		sys.exit()
	elif chpasswd not in [0,1]:
		print 'invalid value for <changePassword>!'
		sys.exit()

	# inverted logic
	disabled=str( 1 - status )

	###

	# outfile = os.path.basename(actgrp+'.csv')
	outfile = "/var/lib/ucs-school-import/activate-grp-%s-%s.csv" % (time.strftime("%Y%m%d-%H%M%S"), actgrp)
	print "outfile is : "+outfile
	if os.path.exists(outfile):
		print 'outfile %s does already exist. Stopping here.' % outfile
		sys.exit()
	outf = open(outfile,'w')


	# get group
	objects = univention.admin.modules.lookup(group_module, co, lo, scope='sub', superordinate=superordinate, base=baseDN,
											  filter=univention.admin.filter.expression('cn',actgrp))
	out_line = ('%%s%(sep)s' * 7 + '\n') % {'sep':sepchar}
	for grp in objects:

		# get group members
		if "uniqueMember" in grp.oldattr:
			grpmembers = grp.oldattr["uniqueMember"]
			for memberdn in grpmembers:

				membergrplist = ""
				grpobjlist = univention.admin.modules.lookup(group_module, co, lo, scope='sub', superordinate=superordinate, base=baseDN,
														  filter=univention.admin.filter.expression('uniqueMember', memberdn))
				for grpobj in grpobjlist:
					if grpobj.dn != grp.dn:
						if len(membergrplist):
							membergrplist += "," + grpobj.oldattr["cn"][0]
						else:
							membergrplist += grpobj.oldattr["cn"][0]

				# modify each member
				memberobj = univention.admin.objects.get(user_module, co, lo, position='', dn=memberdn, arg='')
				count_lo()
				memberobj.open()

				memberobj['disabled'] = str(disabled)
				memberobj.modify()

				print memberdn,
				if status == 0:
					print 'deactivated',
				else:
					print 'activated',

				passwd = '*'
				if chpasswd:
					passwd = create_passwd()
					memberobj['password'] = passwd
					memberobj['overridePWHistory'] = '1'
					memberobj['overridePWLength'] = '1'
					memberobj.modify()
					print 'and set random password',

				# write csv line
				snr = memberdn[ memberdn.find('ou=') + 3 : ]
				snr = snr[ : snr.find(',') ]
				outf.write(out_line % (snr, actgrp, memberobj['firstname'], memberobj['lastname'], passwd, memberobj['mailPrimaryAddress'], membergrplist))

				print

	outf.close()

def export_computer():
	#  syntax: $0 <ou> <filename>"
	# <ou>        computers of OU <ou> shall be exported
	# <filename>  output filename

	if len(sys.argv) != 3:
		print 'must have at least two arguments'
		print 'export_computer <ou> <output-filename>'
		print ''
		sys.exit()
	ou = sys.argv[1]
	outfile = sys.argv[2]

	# outfile = os.path.basename(actgrp+'.csv')
	print "outfile is : "+outfile
	if os.path.exists(outfile):
		print 'outfile %s does already exist. Stopping here.' % outfile
		sys.exit()
	outf = open(outfile,'w')

	ouBaseDN = getDN (ou)

	# get group
	print 'looking for objects... please wait...'
	objects = univention.admin.modules.lookup(computer_module, co, lo, scope='sub', superordinate=superordinate, base=ouBaseDN, filter=None)
	print 'writing data of %d objects...' % len(objects)
	out_line = ('%%s%(sep)s' * 5 + '\n') % {'sep':sepchar}
	for host in objects:
		host.open()
		inventoryNumber = ''
		ip = ''
		mac = ''
		if host.has_key('inventoryNumber') and host['inventoryNumber']:
			inventoryNumber = host['inventoryNumber'][0]
		if host.has_key('ip') and host['ip']:
			ip = host['ip'][0]
		if host.has_key('mac') and host['mac']:
			mac = host['mac'][0]
#		Name,OU,1.Zeile Inventar-Nr.,IP-Adresse
		outf.write(out_line % (host['name'], ou, inventoryNumber, ip, mac))
	outf.close()

#------------------------------------------------------------------------------------------#

# init univention-directory-manager
tls=2

secretFile=open('/etc/ldap.secret','r')
pwdLine=secretFile.readline()
pwd=re.sub('\n','',pwdLine)

locounts=0
lo = None
try:
	lo=univention.admin.uldap.access(host=configRegistry['ldap/master'], base=baseDN, binddn='cn=admin,'+baseDN, bindpw=pwd, start_tls=tls)
except Exception, e:
	univention.debug.debug(univention.debug.ADMIN, univention.debug.WARN, 'authentication error: %s' % str(e))
	print 'ERROR: authentication error: %s' % str(e)
	sys.exit(1)

co            = univention.admin.config.config()
position      = univention.admin.uldap.position(baseDN)
superordinate = None


user_module                = univention.admin.modules.get("users/user")
group_module               = univention.admin.modules.get("groups/group")
cn_module                  = univention.admin.modules.get("container/cn")
ou_module                  = univention.admin.modules.get("container/ou")
server_module              = univention.admin.modules.get("computers/domaincontroller_slave")
share_module               = univention.admin.modules.get("shares/share")
printer_module             = univention.admin.modules.get("shares/printer")
computer_module            = univention.admin.modules.get("computers/computer")

dhcp_server_module         = univention.admin.modules.get("dhcp/server")
dhcp_service_module        = univention.admin.modules.get("dhcp/service")
dhcp_subnet_module         = univention.admin.modules.get("dhcp/subnet")

dns_reverse_zone_module    = univention.admin.modules.get("dns/reverse_zone")

network_module             = univention.admin.modules.get("networks/network")

policy_dhcp_routing_module = univention.admin.modules.get("policies/dhcp_routing")
policy_dhcp_netbios_module = univention.admin.modules.get("policies/dhcp_netbios")
policy_dhcp_dns_module     = univention.admin.modules.get("policies/dhcp_dns")

for m in (
		user_module,
		group_module,
		cn_module,
		ou_module,
		server_module,
		share_module,
		printer_module,
		computer_module,
		dhcp_server_module,
		dhcp_service_module,
		dhcp_subnet_module,
		dns_reverse_zone_module,
		network_module,
		policy_dhcp_routing_module,
		policy_dhcp_netbios_module,
		policy_dhcp_dns_module,
		):
	univention.admin.modules.init (lo, position, m)

# get default group
default_group = "cn=Domain Users,cn=groups,%s"%baseDN # fallback
setting_module = univention.admin.modules.get("settings/default")
for object in univention.admin.modules.lookup(setting_module, co, lo, scope='sub', superordinate=superordinate, base='', filter=''):
	if object.has_key("defaultGroup"):
		default_group=object["defaultGroup"]
	else: print "WARNING, no default group found"
count_lo()

# select action
if sys.argv[0].endswith("import_user") or sys.argv[0].endswith("ucs-school-import"):
	import_user()
elif sys.argv[0].endswith("import_networks"):
	import_networks()
elif sys.argv[0].endswith("import_computer"):
	import_computer()
elif sys.argv[0].endswith("import_router"):
	import_router()
elif sys.argv[0].endswith("import_inventory_number"):
	set_inventory_number_for_computer()
elif sys.argv[0].endswith("import_group"):
	import_group()
elif sys.argv[0].endswith("import_printer"):
	import_printer()
elif sys.argv[0].endswith("create_ou"):
	# argument is schoolNr
	if len(sys.argv)>1:
		schoolNr = sys.argv[1]
	else:
		print "must have one Argument for schoolNr"
		sys.exit()
	verify_school_ou(schoolNr, co, lo, baseDN)
elif sys.argv[0].endswith("activate_groupmembers"):
	activate_groupmembers()
elif sys.argv[0].endswith("export_computer"):
	export_computer()
else:
	print "unknown action defined by the filename"
