#!/usr/bin/python2.6
# -*- coding: utf-8 -*-
#
# Univention UCS@School
#
# Copyright 2007-2012 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

import optparse, sys, os, socket, copy
import univention.uldap as uuldap
import univention.config_registry
import ldap


def main():
	configRegistry = univention.config_registry.ConfigRegistry()
	configRegistry.load()

	parser = optparse.OptionParser( )
	parser.add_option("-n", "--dry-run", dest="dryrun", default=False, action="store_true", help="perform dry-run")
	parser.add_option("-o", "--ou", dest="ou", default=[], action="store", help="process only ou OU")
	parser.add_option("-D", "--binddn", dest="binddn", default=None, action="store", help="bind DN")
	parser.add_option("-w", "--bindpwd", dest="bindpwd", default=None, action="store", help="bind password")
	(options, args) = parser.parse_args()

	if not options.binddn:
		if not configRegistry.get('server/role','') == 'domaincontroller_master':
			print 'E: please run command as user root on'
			print 'E: domaincontroller_master or specify binddn and bindpwd!'
			sys.exit(2)
		elif os.getuid() != 0:
			print 'E: please run command as user root or'
			print 'E: specify binddn and bindpwd!'
			sys.exit(3)

	# get LDAP connection to dc master
	try:
		if options.binddn:
			lo = univention.uldap.access( host = configRegistry.get('ldap/master'), base = configRegistry.get('ldap/base'),
										  binddn = options.binddn, bindpw = options.bindpwd, start_tls = 2, decode_ignorelist = [])
		else:
			lo = uuldap.getAdminConnection()
	except Exception, e:
		print 'E: cannot connect to ldap server: %s' % str(e)
		sys.exit(1)


	oufilter=''
	if options.ou:
		oufilter='(ou=%s)' % options.ou

	try:
		oulist = lo.searchDn( filter = '(&(ou=*)%s)' % oufilter, scope='one', base=configRegistry.get('ldap/base') )
	except ldap.NO_SUCH_OBJECT:
		oulist = []

	if not oulist:
		print 'no ou found'

	for ou in oulist:
		for usertype, uservalue in ( ('pupils', 'pupil'), ('teachers', 'teacher'), ('staff', 'staff') ):
			container = configRegistry.get('ucsschool/ldap/default/container/%s' % usertype)
			if not container:
				print 'UCR variable ucsschool/ldap/default/container/%s is not set!' % usertype
				sys.exit(4)

			userbase = 'cn=%s,cn=users,%s' % (container, ou)
			print 'processing ou %s' % userbase
			try:
				userlist = lo.search( base=userbase, filter='(&(uid=*)(!(ucsschoolRole=*)))' )
			except ldap.NO_SUCH_OBJECT:
				userlist = []

			userlistlen = len(userlist)
			i=0
			for userdn, userattr in userlist:
				i += 1
				modlist = []

				old = userattr.get('objectClass')
				if not 'univentionUcsSchoolUser' in old:
					new = copy.deepcopy( userattr.get('objectClass') )
					new.append('univentionUcsSchoolUser')
					modlist.append( [ 'objectClass', old, new ] )

				old = userattr.get('ucsschoolRole')
				if not old:
					modlist.append( [ 'ucsschoolRole', '', uservalue ] )

				if modlist:
					if not options.dryrun:
						print '(%s/%s) modifying %s' % (i, userlistlen, userdn)
						try:
							lo.modify(userdn, modlist)
							pass
						except Exception, e:
							print 'modifying %s failed: %s' % (userdn, str(e))
					else:
						print '(%s/%s) would modify %s' % (i, userlistlen, userdn)


	print 'done.'

if __name__ == '__main__':
	main()
